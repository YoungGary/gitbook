{"./":{"url":"./","title":"写在前面","keywords":"","body":" 前言 欢迎来到Gary的小窝 这里记录着自己学习成长的点点滴滴 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 15:02:27 "},"leetcode/":{"url":"leetcode/","title":"Leetcode之旅","keywords":"","body":" LeetCode LeetCode是个题库，里面有很多编程面试的算法题目，可以在线编译运行。 在这里，你可以使用 C、C++、Java、Python、PHP、JavaScript 等共 14 种编程语言进行解题。 本系列文章会记录自己使用JavaScript语言去解答每道题的过程 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 15:02:23 "},"leetcode/1.html":{"url":"leetcode/1.html","title":"1.两数之和","keywords":"","body":" 001. 两数之和 一 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 二 解题过程 拿到题目很容易想到数组循环遍历判断，于是我三下五除二写出了这样的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { if(!nums instanceof Array){ return; } for(let i = 0 ; i 使用双层循环去遍历数组，如果找的到就返回索引值，这个算法的复杂度是O（n2）. 我满怀欣喜的提交代码去验证答案，得到的结果是通过，但是复杂度有些过高了,内存占也有点大 内存消耗 :34.7 MB, 在所有 JavaScript 提交中击败了41.93%的用户 所以我苦思冥想，可不可以不用二次循环的方式解题。于是我想到了 indexOf indexOf()：判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。 于是就会有了下面的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let result = []; nums.map((item, index) => { if (nums.indexOf(target - item) > -1 && nums.indexOf(target - item) != index) { result = [index, nums.indexOf(target - item)].sort((a, b) => a > b); } }); return result; }; 通过遍历一次数组 ，使用 indexOf() 寻找除当前 item 的 index 之外和 item 相加之和为 target 的结果。 最后，我们返回查找的最新结果，该结果进行了排序（[4, 2] 的返回通过 sort() 排序变成 [2, 4]） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 16:07:51 "},"leetcode/2.html":{"url":"leetcode/2.html","title":"2.两数相加","keywords":"","body":" 002. 两数相加 一 题目描述 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 二 解题过程 这个题目是用一段程序把人在大脑中如何进行的加法计算出来。单链表中每一个节点的数据结构，其实是一个对象，val属性是表示当前节点的值，next属性是表示下一个节点。就像这样 function ListNode(val) { this.val = val; this.next = null; } 单链表的相加比较麻烦，这道题可以把2个单链表转化成数组 然后进行数组中每个元素相加的操作。然后把最后的数组 转化成一个链表的数据结构。代码如下 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { if(!l1){ return l2; } if(!l2){ return l1; } //把链表转成数组 var arr1 = []; var arr2 = []; var res = []; while(l1){ arr1.push(l1.val); l1=l1.next; } while(l2){ arr2.push(l2.val); l2=l2.next; } //此时arr1 和arr2 就转化成了数组 //数组的每一个位数的相加，jdg 表示进位，如果两个数相加大于9 就要进行进位操作+1 //把最后的结果push 到新数组中 var jdg=false,newArr=[],sum=null,num=null, len=Math.max(arr1.length,arr2.length); for(var i = 0 ; i =10); newArr.push(num); } //如果第一位还是有进位 push 1 if(jdg){ newArr.push(1); } //将返回的数字转成链表 var result = newArr; var node={ val:null, next:null }, head = node; for(i=0;i 提交成功， 内存消耗 :39.5 MB, 在所有 JavaScript 提交中击败了11.87%的用，优化方案苦思冥想中。。。 to be continued Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-19 09:45:44 "},"leetcode/3.html":{"url":"leetcode/3.html","title":"3.无重复字符的最长子串","keywords":"","body":" 003. 无重复字符的最长子串 一 题目描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 例如： 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 二 解题过程 这道题还是比较有思路的，要找出没有重复的最长子串，就只需要遍历这个字符串 然后用数组维护一个队列，当遍历出的字符 不存在这个队列中时候，就push进 这个数组 当这个字符存在于这个队列中的时候，就‘先进先出’ 把第一个字符删除 然后继续遍历这个字符串 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(str) { let arr = [] let res = 0; let i = 0; while(i Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-30 10:55:53 "},"leetcode/4.html":{"url":"leetcode/4.html","title":"4.寻找两个有序数组的中位数","keywords":"","body":" 004. 寻找两个有序数组的中位数 一 题目描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 例如： nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 二 解题过程 2个有序的数组 找中位数 其实思路就是把两个数组 合并成一个有序的数组 再求中位数 。如果这个数组的个数是奇数 那么中位数就是中间的那个数 否则就是2个中间的值除2 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */ var findMedianSortedArrays = function(nums1, nums2) { var arr= nums1.concat(nums2).sort((a, b) => a - b); const { length } = arr; return length % 2 ? arr[Math.floor(length / 2)] : (arr[length / 2] + arr[length / 2 - 1]) / 2; }; 执行用时 :212 ms, 在所有 JavaScript 提交中击败了46.94%的用户 内存消耗 :39.8 MB, 在所有 JavaScript 提交中击败了32.79%的用户 洋洋洒洒几行代码 但是这明显不是最优解 JS内部提供的排序算法sort 内部是使用快速排序和插入排序算法 时间复杂度 都是O（log2n） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-19 15:18:30 "},"leetcode/6.html":{"url":"leetcode/6.html","title":"6.Z字形变换","keywords":"","body":" 006. Z字型变换 一 题目描述 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例1： 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例2： 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G 二 解题过程 首先想到就是使用队列。几行就要用几个队列的形式把字符串按照方式插入队列最后再一起循环遍历出来。 1.首先用数组的形式，每一项就是一个字符串代表每个队列。 2.遍历字符串，用是否向下的标记 标记遍历的方向， 当行数 = 0 或者 length-1的时候需要转向。 3.最后把几个队列合并成一个字符串 /** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { if(numRows == 1){ return s; } var arr = []; var len = Math.min(s.length,numRows); for(var i = 0; i Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-30 10:55:54 "},"leetcode/9.html":{"url":"leetcode/9.html","title":"9.回文数","keywords":"","body":" 009. 回文数 一 题目描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1： 输入: 121 输出: true 示例2： 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3： 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 二 解题过程 判断回文数，就是判断从前往后遍历到中位数的值 和从后往前遍历 所得的数相同。数字可以通过遍历，不断的整除10，得到从前往后的数字， 通过%10 得到剩余的最后一位的值 把后面的值组合起来和前面遍历的值进行比较 得到true 或者false 注意数字的个数 是奇数 和偶数的情况，判断有所不同。 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { if(x revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x = Math.floor(x / 10); } return x == revertedNumber || x == Math.floor(revertedNumber / 10) }; 坑： Java当中的整除 和JavaScript 中不一样。 Java中直接用 a/b 得到的就是整除。 JS中不同，得用 Math.floor(revertedNumber / 10) 这种方式 才行， 遗忘了。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-30 10:55:55 "},"leetcode/11.html":{"url":"leetcode/11.html","title":"11.盛最多水的容器","keywords":"","body":" 011. 盛最多水的容器 一 题目描述 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2 示例1： 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 二 解题过程 双指针解法。 在数组的最左边 和最右边 做标记，计算他们的乘积，容纳的水 是以小的那个值为单位，乘以 两个标记之间的值。 每次两个指针总是 小的值朝大的值 方向移动一个 一直循环 直到两个指针碰头。 最后计算的最大值 就是结果 /** * @param {number[]} height * @return {number} */ var maxArea = function(height) { var max = 0; var left = 0; var right = height.length -1; while(left Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-28 17:28:17 "},"leetcode/12.html":{"url":"leetcode/12.html","title":"12.整数转罗马数字","keywords":"","body":" 012. 整数转罗马数字 一 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例1： 输入: 3 输出: \"III\" 示例2： 输入: 4 输出: \"IV\" 示例3： 输入: 9 输出: \"IX\" 示例4： 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例5： 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 二 解题过程 思路还是比较清晰的 把每位数字 取出来 根据不同情况判断 是否是4 或者是5或者9 转换成罗马数字 最后拼成一个字符串 /** * @param {number} num * @return {string} */ var intToRoman = function(num) { // 输入的数字在1到3999 范围内 if(num > 3999 || num 0){ for(var i = 0 ; i 0 && hundred 4 && hundred0 && ten 4 && ten0 && one 4 && one 三 思考 上述解法是比较暴力的 当我查看了官方题解后，发现了一种新的解法，贪心算法。 四 贪心算法 在生活中的例子： 在以前还使用现金购物的年代，如果我们不想让对方找钱，付款的时候我们会尽量拿面值大的纸币给对方，这样才会使得我们给对方的纸币张数最少，对方点钱的时候（因为对方要检验你给的钱对不对）也最方便。最极端的一种情况，你要是都拿零钱去买一个比较贵重的东西，我相信没有人是很高兴收到你的钱的，因为他们点钱费劲。 整数转罗马数字”与上面的问题是一模一样的思想：在表示一个较大整数的时候，“罗马数字”不会让你都用 11 加起来，肯定是写出来的“罗马数字”的个数越少越好。 于这道问题，“纸币”有哪些，并不是只有题目中给出的对应关系，根据规则，还可以得到一些“纸币”的面值，不过都是有限个“纸币”，很快就能罗列出来。 于是解这道题的思路就出来了： “纸币”有哪些？ 一个整数如何做“加法因子”的分解？ 思路分析： 从题目中给出的“罗马数字”与阿拉伯数字的对应关系，和翻译规则，我们需要推导出“罗马数字”还有哪些组合。 罗马数字 阿拉伯数字 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 为此，我们要举例子帮助我们发现规律： 阿拉伯数字 转换规则 罗马数字 1 直接看表 I 2 2=1+1，相同数字简单叠加 II 3 3=1+1+1，相同数字简单叠加 III 4 不能写成 4 = 1 + 1 + 1 + 14=1+1+1+1，44 应该看做 4 = 5 - 14=5−1 IV 5 直接看表 V 6 6=5+1，大数字在前，小数字在后 VI 7 7=5+1+1，大数字在前，小数字在后，相同数字简单叠加 VII 8 8=5+1+1+1，大数字在前，小数字在后，相同数字简单叠加 VIII 9 不能写成 9 = 5 + 1 + 1 + 1 + 19=5+1+1+1+1，99 应该看做 9 = 10 - 19=10−1 IX 10 直接看表 X 于是，我们发现（其实在题目中已经强调了这些特例），出现 44、99、4040、9090、400400、900900 （40004000、90009000 不讨论了，题目测试用例中有说，不会超过 39993999）的情况比较特殊一些，做的是减法，把它们也加入到“罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列。 罗马数字 阿拉伯数字 M 1000 CM 900 D 500 CD 400 C 100 XC 90 L 50 XL 40 X 10 IX 9 V 5 IV 4 I 1 于是，“将整数转换为阿拉伯数字”的过程，就是我们用上面这张表中右边的数字作为“加法因子”去分解一个整数，并且分解的整数个数越少越好，即尽量使用靠前的数字，这可以认为是一种贪心法则。 var intToRoman = function(num) { var nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] var romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"] var index = 0 var res = '' while (index nums[index] || num == nums[index]){ res += romans[index] num -= nums[index] } index += 1 } return res }; Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-30 10:56:22 "},"leetcode/13.html":{"url":"leetcode/13.html","title":"13.罗马数字转整数","keywords":"","body":"013. 罗马数字转整数 一 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例1： 输入: \"III\" 输出: 3 示例2： 输入: \"IV\" 输出: 4 示例3： 输入: \"IX\" 输出: 9 示例4： 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例5： 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 二 解题过程 在12题中，使用到了贪心算法 来解决数字和罗马字符之间的转换问题 我们同样可以使用这个思想来进行罗马字符和数字之间的转换。 /** * @param {string} s * @return {number} */ var romanToInt = function(s) { var nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; var romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]; var number = 0; var index = 0; var str = s; while (index Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-30 10:56:21 "}}