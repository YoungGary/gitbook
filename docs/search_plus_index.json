{"./":{"url":"./","title":"写在前面","keywords":"","body":" 前言 欢迎来到Gary的小窝 这里记录着自己学习成长的点点滴滴 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 15:02:27 "},"leetcode/":{"url":"leetcode/","title":"Leetcode之旅","keywords":"","body":" LeetCode LeetCode是个题库，里面有很多编程面试的算法题目，可以在线编译运行。 在这里，你可以使用 C、C++、Java、Python、PHP、JavaScript 等共 14 种编程语言进行解题。 本系列文章会记录自己使用JavaScript语言去解答每道题的过程 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 15:02:23 "},"leetcode/1.html":{"url":"leetcode/1.html","title":"1.两数之和","keywords":"","body":" 001. 两数之和 一 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 二 解题过程 拿到题目很容易想到数组循环遍历判断，于是我三下五除二写出了这样的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { if(!nums instanceof Array){ return; } for(let i = 0 ; i 使用双层循环去遍历数组，如果找的到就返回索引值，这个算法的复杂度是O（n2）. 我满怀欣喜的提交代码去验证答案，得到的结果是通过，但是复杂度有些过高了,内存占也有点大 内存消耗 :34.7 MB, 在所有 JavaScript 提交中击败了41.93%的用户 所以我苦思冥想，可不可以不用二次循环的方式解题。于是我想到了 indexOf indexOf()：判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。 于是就会有了下面的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let result = []; nums.map((item, index) => { if (nums.indexOf(target - item) > -1 && nums.indexOf(target - item) != index) { result = [index, nums.indexOf(target - item)].sort((a, b) => a > b); } }); return result; }; 通过遍历一次数组 ，使用 indexOf() 寻找除当前 item 的 index 之外和 item 相加之和为 target 的结果。 最后，我们返回查找的最新结果，该结果进行了排序（[4, 2] 的返回通过 sort() 排序变成 [2, 4]） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 16:07:51 "},"leetcode/2.html":{"url":"leetcode/2.html","title":"2.两数相加","keywords":"","body":" 002. 两数相加 一 题目描述 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 二 解题过程 这个题目是用程序把人脑的加法计算出来。单链表的一个节点的数据结构，其实是一个对象，val属性是表示当前节点的值，next属性是表示下一个节点。就像这样 function ListNode(val) { this.val = val; this.next = null; } 单链表的相加比较麻烦，我把这道题转化成数组 然后进行相加的操作。然后把最后的数组 转化成链表的数据结构。 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { if(!l1){ return l2; } if(!l2){ return l1; } //把链表转成数组 var arr1 = []; var arr2 = []; var res = []; while(l1){ arr1.push(l1.val); l1=l1.next; } while(l2){ arr2.push(l2.val); l2=l2.next; } //数组的相加，jdg 表示进位，如果两个数相加大于9 就要进行进位操作 //把最后的结果push 到新数组中 var jdg=false,newArr=[],sum=null,num=null, len=Math.max(arr1.length,arr2.length); for(var i = 0 ; i =10); newArr.push(num); } //如果第一位还是有进位 push 1 if(jdg){ newArr.push(1); } //将返回的数字转成链表 var result = newArr; var node={ val:null, next:null }, head = node; for(i=0;i 提交成功， 内存消耗 :39.5 MB, 在所有 JavaScript 提交中击败了11.87%的用，优化方案苦思冥想中。。。 to be continued Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-17 16:32:16 "}}