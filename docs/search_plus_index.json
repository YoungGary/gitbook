{"./":{"url":"./","title":"写在前面","keywords":"","body":"前言 欢迎来到Gary的小窝 这里记录着自己学习成长的点点滴滴和生活的碎碎念 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 20:22:17 "},"leetcode/":{"url":"leetcode/","title":"Leetcode之旅","keywords":"","body":" LeetCode LeetCode是个题库，里面有很多编程面试的算法题目，可以在线编译运行。 在这里，你可以使用 C、C++、Java、Python、PHP、JavaScript 等共 14 种编程语言进行解题。 本系列文章会记录自己使用JavaScript语言去解答每道题的过程 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 19:30:13 "},"leetcode/1.html":{"url":"leetcode/1.html","title":"1.两数之和","keywords":"","body":" 001. 两数之和 一 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 二 解题过程 拿到题目很容易想到数组循环遍历判断，于是我三下五除二写出了这样的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { if(!nums instanceof Array){ return; } for(let i = 0 ; i 使用双层循环去遍历数组，如果找的到就返回索引值，这个算法的复杂度是O（n2）. 我满怀欣喜的提交代码去验证答案，得到的结果是通过，但是复杂度有些过高了,内存占也有点大 内存消耗 :34.7 MB, 在所有 JavaScript 提交中击败了41.93%的用户 所以我苦思冥想，可不可以不用二次循环的方式解题。于是我想到了 indexOf indexOf()：判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。 于是就会有了下面的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let result = []; nums.map((item, index) => { if (nums.indexOf(target - item) > -1 && nums.indexOf(target - item) != index) { result = [index, nums.indexOf(target - item)].sort((a, b) => a > b); } }); return result; }; 通过遍历一次数组 ，使用 indexOf() 寻找除当前 item 的 index 之外和 item 相加之和为 target 的结果。 最后，我们返回查找的最新结果，该结果进行了排序（[4, 2] 的返回通过 sort() 排序变成 [2, 4]） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-18 19:30:13 "},"leetcode/2.html":{"url":"leetcode/2.html","title":"2.两数相加","keywords":"","body":" 002. 两数相加 一 题目描述 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 二 解题过程 这个题目是用一段程序把人在大脑中如何进行的加法计算出来。单链表中每一个节点的数据结构，其实是一个对象，val属性是表示当前节点的值，next属性是表示下一个节点。就像这样 function ListNode(val) { this.val = val; this.next = null; } 单链表的相加比较麻烦，这道题可以把2个单链表转化成数组 然后进行数组中每个元素相加的操作。然后把最后的数组 转化成一个链表的数据结构。代码如下 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { if(!l1){ return l2; } if(!l2){ return l1; } //把链表转成数组 var arr1 = []; var arr2 = []; var res = []; while(l1){ arr1.push(l1.val); l1=l1.next; } while(l2){ arr2.push(l2.val); l2=l2.next; } //此时arr1 和arr2 就转化成了数组 //数组的每一个位数的相加，jdg 表示进位，如果两个数相加大于9 就要进行进位操作+1 //把最后的结果push 到新数组中 var jdg=false,newArr=[],sum=null,num=null, len=Math.max(arr1.length,arr2.length); for(var i = 0 ; i =10); newArr.push(num); } //如果第一位还是有进位 push 1 if(jdg){ newArr.push(1); } //将返回的数字转成链表 var result = newArr; var node={ val:null, next:null }, head = node; for(i=0;i 提交成功， 内存消耗 :39.5 MB, 在所有 JavaScript 提交中击败了11.87%的用，优化方案苦思冥想中。。。 to be continued Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/3.html":{"url":"leetcode/3.html","title":"3.无重复字符的最长子串","keywords":"","body":" 003. 无重复字符的最长子串 一 题目描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 例如： 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 二 解题过程 这道题还是比较有思路的，要找出没有重复的最长子串，就只需要遍历这个字符串 然后用数组维护一个队列，当遍历出的字符 不存在这个队列中时候，就push进 这个数组 当这个字符存在于这个队列中的时候，就‘先进先出’ 把第一个字符删除 然后继续遍历这个字符串 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(str) { let arr = [] let res = 0; let i = 0; while(i Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/4.html":{"url":"leetcode/4.html","title":"4.寻找两个有序数组的中位数","keywords":"","body":" 004. 寻找两个有序数组的中位数 一 题目描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 例如： nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 二 解题过程 2个有序的数组 找中位数 其实思路就是把两个数组 合并成一个有序的数组 再求中位数 。如果这个数组的个数是奇数 那么中位数就是中间的那个数 否则就是2个中间的值除2 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */ var findMedianSortedArrays = function(nums1, nums2) { var arr= nums1.concat(nums2).sort((a, b) => a - b); const { length } = arr; return length % 2 ? arr[Math.floor(length / 2)] : (arr[length / 2] + arr[length / 2 - 1]) / 2; }; 执行用时 :212 ms, 在所有 JavaScript 提交中击败了46.94%的用户 内存消耗 :39.8 MB, 在所有 JavaScript 提交中击败了32.79%的用户 洋洋洒洒几行代码 但是这明显不是最优解 JS内部提供的排序算法sort 内部是使用快速排序和插入排序算法 时间复杂度 都是O（log2n） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/6.html":{"url":"leetcode/6.html","title":"6.Z字形变换","keywords":"","body":" 006. Z字型变换 一 题目描述 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例1： 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例2： 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G 二 解题过程 首先想到就是使用队列。几行就要用几个队列的形式把字符串按照方式插入队列最后再一起循环遍历出来。 1.首先用数组的形式，每一项就是一个字符串代表每个队列。 2.遍历字符串，用是否向下的标记 标记遍历的方向， 当行数 = 0 或者 length-1的时候需要转向。 3.最后把几个队列合并成一个字符串 /** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { if(numRows == 1){ return s; } var arr = []; var len = Math.min(s.length,numRows); for(var i = 0; i Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/9.html":{"url":"leetcode/9.html","title":"9.回文数","keywords":"","body":" 009. 回文数 一 题目描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1： 输入: 121 输出: true 示例2： 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3： 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 二 解题过程 判断回文数，就是判断从前往后遍历到中位数的值 和从后往前遍历 所得的数相同。数字可以通过遍历，不断的整除10，得到从前往后的数字， 通过%10 得到剩余的最后一位的值 把后面的值组合起来和前面遍历的值进行比较 得到true 或者false 注意数字的个数 是奇数 和偶数的情况，判断有所不同。 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { if(x revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x = Math.floor(x / 10); } return x == revertedNumber || x == Math.floor(revertedNumber / 10) }; 坑： Java当中的整除 和JavaScript 中不一样。 Java中直接用 a/b 得到的就是整除。 JS中不同，得用 Math.floor(revertedNumber / 10) 这种方式 才行， 遗忘了。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/11.html":{"url":"leetcode/11.html","title":"11.盛最多水的容器","keywords":"","body":" 011. 盛最多水的容器 一 题目描述 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2 示例1： 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 二 解题过程 双指针解法。 在数组的最左边 和最右边 做标记，计算他们的乘积，容纳的水 是以小的那个值为单位，乘以 两个标记之间的值。 每次两个指针总是 小的值朝大的值 方向移动一个 一直循环 直到两个指针碰头。 最后计算的最大值 就是结果 /** * @param {number[]} height * @return {number} */ var maxArea = function(height) { var max = 0; var left = 0; var right = height.length -1; while(left Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/12.html":{"url":"leetcode/12.html","title":"12.整数转罗马数字","keywords":"","body":" 012. 整数转罗马数字 一 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例1： 输入: 3 输出: \"III\" 示例2： 输入: 4 输出: \"IV\" 示例3： 输入: 9 输出: \"IX\" 示例4： 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例5： 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 二 解题过程 思路还是比较清晰的 把每位数字 取出来 根据不同情况判断 是否是4 或者是5或者9 转换成罗马数字 最后拼成一个字符串 /** * @param {number} num * @return {string} */ var intToRoman = function(num) { // 输入的数字在1到3999 范围内 if(num > 3999 || num 0){ for(var i = 0 ; i 0 && hundred 4 && hundred0 && ten 4 && ten0 && one 4 && one 三 思考 上述解法是比较暴力的 当我查看了官方题解后，发现了一种新的解法，贪心算法。 四 贪心算法 在生活中的例子： 在以前还使用现金购物的年代，如果我们不想让对方找钱，付款的时候我们会尽量拿面值大的纸币给对方，这样才会使得我们给对方的纸币张数最少，对方点钱的时候（因为对方要检验你给的钱对不对）也最方便。最极端的一种情况，你要是都拿零钱去买一个比较贵重的东西，我相信没有人是很高兴收到你的钱的，因为他们点钱费劲。 整数转罗马数字”与上面的问题是一模一样的思想：在表示一个较大整数的时候，“罗马数字”不会让你都用 11 加起来，肯定是写出来的“罗马数字”的个数越少越好。 于这道问题，“纸币”有哪些，并不是只有题目中给出的对应关系，根据规则，还可以得到一些“纸币”的面值，不过都是有限个“纸币”，很快就能罗列出来。 于是解这道题的思路就出来了： “纸币”有哪些？ 一个整数如何做“加法因子”的分解？ 思路分析： 从题目中给出的“罗马数字”与阿拉伯数字的对应关系，和翻译规则，我们需要推导出“罗马数字”还有哪些组合。 罗马数字 阿拉伯数字 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 为此，我们要举例子帮助我们发现规律： 阿拉伯数字 转换规则 罗马数字 1 直接看表 I 2 2=1+1，相同数字简单叠加 II 3 3=1+1+1，相同数字简单叠加 III 4 不能写成 4 = 1 + 1 + 1 + 14=1+1+1+1，44 应该看做 4 = 5 - 14=5−1 IV 5 直接看表 V 6 6=5+1，大数字在前，小数字在后 VI 7 7=5+1+1，大数字在前，小数字在后，相同数字简单叠加 VII 8 8=5+1+1+1，大数字在前，小数字在后，相同数字简单叠加 VIII 9 不能写成 9 = 5 + 1 + 1 + 1 + 19=5+1+1+1+1，99 应该看做 9 = 10 - 19=10−1 IX 10 直接看表 X 于是，我们发现（其实在题目中已经强调了这些特例），出现 44、99、4040、9090、400400、900900 （40004000、90009000 不讨论了，题目测试用例中有说，不会超过 39993999）的情况比较特殊一些，做的是减法，把它们也加入到“罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列。 罗马数字 阿拉伯数字 M 1000 CM 900 D 500 CD 400 C 100 XC 90 L 50 XL 40 X 10 IX 9 V 5 IV 4 I 1 于是，“将整数转换为阿拉伯数字”的过程，就是我们用上面这张表中右边的数字作为“加法因子”去分解一个整数，并且分解的整数个数越少越好，即尽量使用靠前的数字，这可以认为是一种贪心法则。 var intToRoman = function(num) { var nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] var romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"] var index = 0 var res = '' while (index nums[index] || num == nums[index]){ res += romans[index] num -= nums[index] } index += 1 } return res }; Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/13.html":{"url":"leetcode/13.html","title":"13.罗马数字转整数","keywords":"","body":"013. 罗马数字转整数 一 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例1： 输入: \"III\" 输出: 3 示例2： 输入: \"IV\" 输出: 4 示例3： 输入: \"IX\" 输出: 9 示例4： 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例5： 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 二 解题过程 在12题中，使用到了贪心算法 来解决数字和罗马字符之间的转换问题 我们同样可以使用这个思想来进行罗马字符和数字之间的转换。 /** * @param {string} s * @return {number} */ var romanToInt = function(s) { var nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; var romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]; var number = 0; var index = 0; var str = s; while (index Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:05:28 "},"leetcode/14.html":{"url":"leetcode/14.html","title":"14.最长公共前缀","keywords":"","body":"014. 最长公共前缀 一 题目描述 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例1： 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例2： 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明 所有输入只包含小写字母 a-z 。 二 解题过程 这题还是比较简单的，数组中取一项 与数组中所有项进行比较，如果这个字符串在数组中其他项中都存在IndexOf = 0 那么表明 最终的字符串就是那一项 ，否则 删除最后一个字符 进行循环比较 最后剩下的那个字符串 就是结果，如果不存在 则为'' /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { if(strs.length == 0){ return '' } //取数组第一项 进行比较 var min = strs[0]; //符号位 判断是否满足 所有项 的前缀 var bool = false; while(bool != true){ bool = strs.every(function(item){ return item.indexOf(min) == 0 }) // 不满足 则 去掉 最后一位 进行循环比较 if(!bool){ min=min.substring(0,min.length-1) } if(min == ''){ bool = true; } } return min; }; Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:29:05 "},"flutter/":{"url":"flutter/","title":"Flutter从入门到放弃","keywords":"","body":"Flutter flutter是Google的移动UI框架，可以快速的在iOS和Android上构建高质量的源生用户界面。Flutter可以与现有的代码一起工作。在全世界，flutter正在被越来越多的开发者和组织使用，并且是免费，开源的。 在本系列中会记录学习Flutter的过程。参考了官方文档和《Fluuter技术与入门实践》这本书。 本系列会省略一些环境搭建的介绍，详细介绍见官方文档 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-07 19:42:49 "},"flutter/chapter1.html":{"url":"flutter/chapter1.html","title":"1.Dart语言","keywords":"","body":"Dart语言 1.Dart重要概念 Dart语言是Google在2011年10月在丹麦举行的Goto会议上宣布，是一种结构化的web编程语言，因为Dart语言拥有一些特性，例如： AOT编辑，JIT编辑，可以轻松的创建60fps运行的流畅动画和转场。不需要单独的声明式布局语言，易学习等特点。 这使得Flutter 使用了Dart这个语言 成为其开发语言。Dart拥有几个概念： 所有东西都是对象，所有的对象都继承自内置的Object类。 程序中指定数据类型使得程序合理的分配内存空间，并且帮助编译器进行语法检查。但是，指定类型不是必须的。Dart 是弱类型语言。 Dart代码在运行前解析。 Dart程序有统一的入口 main() 这一点和C C++ 很像。 Dart语言没有public protected 和 private 的概念。 私有特性 通过 变量 或者函数 加上下划线表示。 Dart语言支持async/await 异步处理 变量 基本数据类型 var声明变量 类似于kotlin,JS中的var，它可以接收任何类型的变量，但最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型，如： var t; t=\"yc\"; // 下面代码在dart中会报错，因为变量t的类型已经确定为String， // 类型一旦确定后则不能再更改其类型。 t=1000; 最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型。因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用var声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定。 变量 var num = 0; var title = \"标题\"; Dart 不需要给变量设置 setter getter 方法， 这和 kotlin 等类似。Dart 中所有的基础类型、类等都继承 Object ，默认值是 NULL， 自带 getter 和 setter ，而如果是 final 或者 const 的话，那么它只有一个 getter 方法。 常量 //final 表示常量 只能设定一次 final name = \"111\"; // name = '222' 会引发一个错误 //static const 组合代表了静态常量 static const String complete = \"COMPLETE\"; final和const区别 两者区别在于：const 变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，并且变量类型可以省略。 基本数据类型 Dart语言的常用的基本数据类型包括： Number String Boolean List Map Number String Boolean 在JS中 很熟悉了。 用var 进行变量赋值的时候会推断成对应的类型 var num = 0; var title = \"标题\"; var mIsLogin = false; List 就是数组 ``` List arr1 = [1,2,3,4]; var arr2 = [1,2,3,4]; print(list); //Output: [1, 2, 3, 4] //Length 长度 print(list.length); //Selecting single value 获取单个值 print(list[1]); //Outout: 2 //Adding a value 添加值到list list.add(10); //Removing a single isntance of value 删除单个值 list.remove(3); //Remove at a particular position 删除指定位置的值 第一个元素索引是0，最后一个元素是length-1 list.removeAt(0); >Map var map = { 'key1': 'value1', 'key2': 'value2', 'key3': 'value3' }; //Fetching the values 获取值 print(map['key1']); //Output: value1 print(map['test']); //Output: null //Add a new value 添加值 map['key4'] = 'value4'; //Length 获取长度 print(map.length); //Check if a key is present 检查是否存在 var containsKey = map.containsKey('value1'); print(containsKey); var entries = map.entries; var values = map.values; 也可以使用map构造函数定义map。 var squares = new Map(); squares[\"a\"] = 1; squares[\"b\"] = 2; squares[\"c\"] = 3.0; squares[\"d\"] = [1,2]; squares[\"e\"] = \"yc逗比\"; print(squares['a']);print(squares['e']); ## 函数 dart中的函数和JavaScript中有点类似。你需要定义就是函数的名字、返回值(有返回值或者void)、参数。 void test(){ var name = fullName('杨充', '逗比'); print(name); } String fullName(String firstName, String lastName) { return \"$firstName $lastName\"; } ``` 参数默认值 你可以给函数的命名参数一个默认值。下面的例子给lastName一个默认值。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 10:42:07 "},"ts/":{"url":"ts/","title":"TypeScript","keywords":"","body":" TypeScript学习并重写axios 本系列文章记录学习ts语法到实战，用ts写axios库并发布 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 12:53:33 "},"ts/1.html":{"url":"ts/1.html","title":"1.安装与上手","keywords":"","body":"安装TypeScript 使用npm来安装 npm install -g typescript 安装成功后在命令行输入 tsc -v 如果输出版本号 表示全局安装成功 第一行TypeScript代码 打开文本编辑工具 如vscode 新建hello.ts文件 function greeter(person) { return \"Hello, \" + person; } let user = \"Jane User\"; document.body.innerHTML = greeter(user); 在命令行上，运行TypeScript编译器： tsc hello.ts 输出结果为一个hello.js文件，它包含了和输入文件中相同的JavsScript代码。 一切准备就绪，我们可以运行这个使用TypeScript写的JavaScript应用了 体验类型注解 ts的类型注解 和swift，kotlin语言中很类似 ，它为函数或变量添加约束的方式。可以指定参数 变量的类型 在变量后用：加上类型名来表示，如： function greeter(person: string) { return \"Hello, \" + person; } 如果你给person 一个错误的类型 如 数组类型，在编译的时候就会报错: hello.ts(7,26): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'. 要注意的是尽管有错误，hello.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。 体验接口 ts中居然有类似Java的接口了。 我们可以使用接口来描述一个拥有某些固定字段的对象。在实现的时候并不是像Java那样实现implements语句，只要包含了接口要求的结构就可以。 interface Person { firstName: string; lastName: string; } function greeter(person: Person) { return \"Hello, \" + person.firstName + \" \" + person.lastName; } let user = { firstName: \"Jane\", lastName: \"User\" }; document.body.innerHTML = greeter(user); 体验类 class User { fullName: string; lastName:string; firstName:string; constructor(firstName:string, lastName:string) { this.firstName = firstName; this.lastName = lastName; this.fullName = firstName + \" \" + lastName; } } function greeter(user : User) { return \"Hello, \" + user.firstName + \" \" + user.lastName; } let user = new User(\"Jane\", \"M.\"); document.body.innerHTML = greeter(user); Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-21 12:53:55 "},"ts/2.html":{"url":"ts/2.html","title":"2.基础类型","keywords":"","body":" 基础类型 布尔值 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。 let isDone: boolean = false; 数字类型 和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 支持十进制，十六进制，二进制和八进制字面量。 //十进制 数字 6 let decLiteral: number = 6; //十六进制 6 let hexLiteral: number = 0xf00d; //二进制 6 let binaryLiteral: number = 0b1010; //八进制 6 let octalLiteral: number = 0o744; 字符串 let name: string = \"bob\"; name = \"smith\"; 字符串的拼接 let name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }. I'll be ${ age + 1 } years old next month.`; 数组 数组有2种定义方式 let list: number[] = [1, 2, 3]; //使用数组泛型 let list: Array = [1, 2, 3]; 元组 Tuple TS中还是加入了元祖类型 （感觉最近5-10年推出的语言都有啊）。 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 // 定义元组类型 let x: [string, number]; // 赋值 x = ['hello', 10]; //这样赋值是错误的 x = [10, 'hello']; 当访问一个已知索引的元素，会得到正确的类型： console.log(x[0].substr(1)); // 正确 console.log(x[1].substr(1)); // 错误 当访问一个越界的元素，会使用联合类型替代： x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型 console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString x[6] = true; // Error, 布尔不是(string | number)类型 注意：在TS 3.1版本之前 访问越界元素 是不会报错的 在3.1版本后就会报错。 枚举 enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 enum Color {Red, Green, Blue} let c: Color = Color.Green; // 0 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号： enum Color {Red = 1, Green, Blue} let c: Color = Color.Green; //2 如果手动赋值所有的值 enum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; //2 可以通过枚举值 反显 枚举名字。 enum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; console.log(colorName); // 显示'Green'因为上面代码里它的值是2 Any 如果你在声明变量的时候 类型不固定 想跳过类型检查 就可以使用any类型 let notSure: any = 4; notSure = \"maybe a string instead\"; notSure = false; // okay, definitely a boolean 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, \"free\"]; list[1] = 100; void 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： void 声明的变量 只能声明 null 或undefined function warnUser(): void { console.log(\"This is my warning message\"); } let unusable: void = undefined; null undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大： let u: undefined = undefined; let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 编译的时候尽可能地使用--strictNullChecks 可以严格模式 检查是否为null never never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\"Something failed\"); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } object object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 declare function create(o: object | null): void; create({ prop: 0 }); // OK create(null); // OK create(42); // Error create(\"string\"); // Error create(false); // Error create(undefined); // Error 类型断言 和转换 假设你使用一个any 类型 来定义一个字符串 这时候你使用length 等方法时候 会报错的，这时候你应该转换成string 类型 再使用字符串的方法。 转换有2种方法 let someValue: any = \"this is a string\"; let strLength: number = (someValue).length; let strLength: number = (someValue as string).length; Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-22 14:45:36 "},"ts/3.html":{"url":"ts/3.html","title":"3.接口","keywords":"","body":"接口 定义 interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: \"Size 10 Object\"}; printLabel(myObj); 可选属性 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): {color: string; area: number} { let newSquare = {color: \"white\", area: 100}; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({color: \"black\"}); 只读属性 readonly 字段 interface Point { readonly x: number; readonly y: number; } let p1: Point = { x: 10, y: 20 }; p1.x = 5; // error! TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! readonly 和const 的区别 是看要把它做为变量使用还是做为一个属性，变量用const 属性用readonly 函数类型 接口也可以定义函数类型 我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result > -1; } //参数名字 可以不同 mySearch = function(sou: string, subSt: string) { let result = sou.search(subSt); return result > -1; } //也可以自己推断 mySearch = function(src, sub) { let result = src.search(sub); return result > -1; } 可索引的类型 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[\"daniel\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： interface StringArray { [index: number]: string; } let myArray: StringArray; myArray = [\"Bob\", \"Fred\"]; let myStr: string = myArray[0]; 类 类型 可以让类来符合一种契约 可以描述属性和方法 interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 类静态部分与实例部分的区别 当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： interface ClockConstructor { new (hour: number, minute: number); } class Clock implements ClockConstructor { currentTime: Date; constructor(h: number, m: number) { } } 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。 继承接口 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 可以继承多个接口 interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke{ sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; square.penWidth = 5.0; 混合类型 一个对象可以同时做为函数和对象使用，并带有额外的属性。 interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { let counter = function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0; 接口继承类 class Control { private state: any; } interface SelectableControl extends Control { select(): void; } class Button extends Control implements SelectableControl { select() { } } class TextBox extends Control { select() { } } // 错误：“Image”类型缺少“state”属性。 class Image implements SelectableControl { select() { } } Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-22 16:15:29 "},"ts/4.html":{"url":"ts/4.html","title":"4.类","keywords":"","body":"类 使用 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } //new 关键字 let greeter = new Greeter(\"world\"); 继承 extends 关键字 class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark() { console.log('Woof! Woof!'); } } const dog = new Dog(); dog.bark(); dog.move(10); dog.bark(); 公共，私有与受保护的修饰符 默认为 public 当成员被标记成 private时，它就不能在声明它的类的外部访问。 当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。 protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问 readonly 修饰符 你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; } } let dad = new Octopus(\"Man with the 8 strong legs\"); dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的. 参数属性 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性： class Octopus { readonly numberOfLegs: number = 8; constructor(readonly name: string) { } } 存取器 类的get set 方法 class Employee { fullName: string; } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { console.log(employee.fullName); } 用 set get 改写 会避免随意修改属性的问题 let passcode = \"secret passcode\"; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode && passcode == \"secret passcode\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } } } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { alert(employee.fullName); } 这段代码在默认情况下会编译失败 存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 所以编译的时候得带参数 --target es5 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-22 22:12:22 "},"life/":{"url":"life/","title":"网事杂谈","keywords":"","body":"前言 这里是对生活的一些碎碎念 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 21:36:56 "},"life/1.html":{"url":"life/1.html","title":"1.周杰伦专辑赏析--叶惠美","keywords":"","body":"叶惠美 2003年7月31日,周杰伦发行了他的全新专辑《叶惠美》，这张以他母亲命名的专辑，在7月16日全亚洲超过50家电台同步首播新专辑主打《以父之名》，全球超过5亿人同时收听，这一天也被命名为周杰伦日。 我的专辑故事 2003年，那时我才5年级，才借到我哥的磁带津津有味的听着上一张专辑《八度空间》，看着磁带的歌词也听不懂他在唱什么，觉得非常酷，当下一张专辑的消息传来，我马上跑到音像店去听，（当时几十的磁带简直是太贵了），当然是听不全的 后来上了初中 有了MP3，才回过头好好的听过这张专辑。下面我作为一个歌迷的角度来赏析这张专辑的所有歌。 以父之名 专辑主打歌。这首歌可是2003年出的，仔细想想 同时期的歌有哪些？两只蝴蝶还是刀郎？ 这首歌一出简直是把华语乐坛全部超越了一番，整首歌基于《教父》系列的世界观，歌的主题以‘天父，教父，父亲’为主轴，说明了教父的无奈，父亲的慈悲，天父的无私，格局相当大气，可谓史诗。 歌词的格局之大 语言之精，丝毫不亚于方文山，这只是黄俊郎在周杰伦歌词的处女座，编曲精良，大气 史诗级别的词，并没有一味的上什么管弦乐，有一种低调的华丽，基本编曲只有打击乐，节奏吉他和base。大多数还是周杰伦的声音为主导，周杰伦的rap水平也是非常厉害，flow和编曲感觉合二为一。（吴亦凡进来挨打！）在主歌部分低沉 ，像是在对你我诉说，副歌突然拔高，像是在对天空诉说。这首主打歌也预示着这张专辑的势如破竹，必将永载史册。音乐犹如周杰伦的玩具，在执掌之间变化万千。这首歌在我心中能在周杰伦的歌中排前五。 懦夫 周杰伦的懦夫是自己创作的一首歌，这首歌也是比较有教育意义的，众所周知，周杰伦是中国的禁毒宣传形象大使，这首歌也是唯一一首以反毒品为主题的歌。这首歌的编曲也是紧跟时尚潮流，以新金属为曲风，激烈抓耳，整首歌有2个叙事视角，一个是瘾君子看到自己的丑陋行为想回头是岸，歌中加入小孩子的声音，以小孩子的角度看到成人世界的丑陋，愤怒的控诉。 晴天 这首歌真的是初闻不知曲中意，再闻已是曲中人。是很多人青春回忆的主题曲。每个人都有初恋，初恋总是青涩美好的，这首歌虽然叫晴天，但是描写的场景全是下雨。网易云音乐歌曲评论最多的歌曲。当我们还对爱情懵懂的时候，你是否也有错过的人呢？那时错过的瞬间便是一生的遗憾。到了今天你还有什么话想对ta说呢？歌曲的本身已不再需要解读，我吹爆。MV也是很美的，周杰伦的MV初吻，雨中独奏大提琴。。当然最后还是要告诉我们喜欢一个人就要大声说出来，不要等到故事的最后，女主送给Jay一个礼物，里面写着Jay I love you. 三年二班 这首歌也是比较有意义的，刚开始的前奏，乒乓球的声音在左右切换，把乒乓球的声音作为节奏的一部分，可太秀了，这首歌听着非常有共鸣，借着乒乓球讲人生，从小家长总在说，别人家的孩子有多优秀，我必须要以他为榜样。我就是我自己，干嘛要和别人比，更何况一个人的优秀与否，只是看成绩吗，我就是跳的比别人高，跑的快，就是比别人更善良，这些行不行呢？难道打乒乓的目的就是得奖？我就是喜欢打，想出点汗行不行？凭什么要用自己的标准要求我，我的人生我要做自己的裁判。所以说那么多年轻人喜欢周杰伦，周杰伦说出了他们的心声啊 东风破 这首歌对于周杰伦来说意义非凡，现在我们都把中国风的标签贴在周杰伦身上，这首歌应该是周杰伦第一首周氏中国风，也是很多人的入坑曲，（我是双节棍入坑的哈哈）。歌词渗透古意，编曲采用中国五声音阶，中西结合，民乐器成为主角，旋律和意境几乎登峰造极，无可挑剔，这首歌风格的创立，才会有后来的菊花台，青花瓷等广为流传的歌。 你听得到 这首歌我超级喜欢。这首歌其实是首广告歌曲，知名度不是那么高。但是这首歌氛围温馨纯净，作词虽然比较简单，但是感情到位，易于理解，配合周杰伦的编曲简单美好，听得出来非常自信。副歌的编曲加上了跳跃性很强的弦乐，把内心的细腻感受描绘出来。‘我想我是太过依赖，在挂电话的刚才’。。第二段中那广为流传的彩蛋，一段话居然是倒放的‘只有你能听得到’，让人津津乐道。MV中周杰伦也是首次扮演一个渣男，在线劈腿（手动笑哭），很好看。 同一种调调 这首歌我超喜欢，又是一首吴亦凡进来挨打的歌，整首歌酷的不讲道理，那时候的我们正在叛逆期，觉得这非常爽非常酷，作曲随性而发，这首歌的rap已经似乎可以脱口而出，那些看上去随便说的“哼哼哈哈一起来”每次都忍不住一起唱，真的是太酷了，MV也是邀请了姚明友情出演。唱跳rap 篮球元素一应俱全（律师函警告）“冰过的饮料，全麦的面包，只收看音乐频道”，方文山的词也是把这种酷表达的淋漓尽致，编曲更是用琵琶作合成器 真是让人大吃一惊，原来民乐器还可以这么玩，这可是2003年啊 她的睫毛 这首歌也是同样一首吹爆的歌。这首歌真的太牛了，这首歌把周杰伦对音乐的企图心展现的淋漓尽致，在编曲中大小调的转换，让作曲人的级别上升一个level，主歌是c小调，用两拍子鼓点，副歌转A大调，色彩瞬间对比亮丽许多。第二段主歌恢复小调，等待着第二遍副歌的到来，但迎来的居然是。。。双副歌，这样子创世纪的玩法，双副歌我后来很少有听过这样的歌了。堪称惊艳，毕竟这是流行音乐啊，打破了一段副歌的旋律，结果这首歌的编曲并没有入围金曲奖最佳编曲，打败他的是《以父之名》，看来打败周杰伦的只有自己了。 爱情悬崖 这首歌我要疯狂pick！！（这句话我好像表达过很多次了）没办法这张专辑每首歌都非常非常好听。这首歌看似比较简单，徐若瑄作词，周杰伦作曲。像是对你诉说一般干净的声音，周杰伦自己说 好听的歌不一定要深奥，和弦不见得要变来变去，传达出想要表达的东西就是好歌，我对这首歌的看法也是这样，真的很好听。 梯田 这首歌可是入围过最佳作词哦，看头的那句吐槽方文山，可把我看笑了“文山啊，等你写好词，我都发下一张专辑咯，没关系，慢慢来，这首歌我自己来”，然后就以第一人称开始叙事，这首歌是表达环境保护思考的一首歌。看吧，周杰伦的歌就是表达的东西很多很有意义。MV也是拿着摄像机自拍，外婆第一次入镜哦，副歌融入了台湾省原住民风格的原生态唱法和歌剧唱法。在2004年的无与伦比演唱会中 这首歌最后还有一段rap，表达的周杰伦对音乐的态度，个性和霸气，我没有跟错人。 双刀 这首歌比较冷门，主题是对民族 历史 文化 正邪的探讨，我觉得方文山在表达鸦片战争之后中国知识分子一直在进行的反思，周杰伦的流行音乐取代了白纸黑字的文章，成为了新时代抒怀民族思绪的载体，双刀的流行成就已经成为全世界流行音乐的最高峰，歌曲主题宏大，家国仇恨，历史民族，这般宏大的叙事一般流行音乐驾驭不住，双刀做到了，在一些地方是隐晦的 表达式克制的，融入说唱，搓盘，效果绝佳。间奏段落仿佛把一部电影的四五首配乐浓缩进了一首流行音乐，制作水准也是绝对的电影级，《双刀》无疑是流行音乐领域的顶配。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 21:40:18 "},"life/2.html":{"url":"life/2.html","title":"2.周杰伦专辑赏析--七里香","keywords":"","body":"七里香 2004年夏天,周杰伦发行了他的全新专辑《七里香》 我的专辑故事 2004年夏天，小学毕业 准备上初中，专辑对我来说还是一个天文数字，在初一的时候 我用作业给别人抄，换来了周杰伦全新专辑磁带，让我听一个寒假，那时候我别提多开心了，回家拿起磁带，放进复读机，反复的听，听了一个过年，我觉得那是最开心的一个过年了，尽管那年亲戚没有回来几个，略显得冷清了些，但是我有周杰伦的歌就足够了，尤其听到七里香，园游会，搁浅，借口，不行了，每一首我都爱。。。 我的地盘 这首歌是周杰伦为了中国移动所作的广告歌，哎~那一句我的地盘听我的，是不是耳熟能详呢，代表年轻人酷的态度，好像从那时候开始 移动的生意开始红火哦，谁没有办过一张动感地带的手机卡呢，校园开学到处都是周杰伦的广告牌，那可真是牌面。这首歌也是非常酷啦，整首歌的尾音都是北京话儿化音，不过rap，词很好表达张扬的个性，但是词真的很难记，2004年演唱会现场忘词，直接成了freestyle 哈哈。 七里香 这首以单曲命名的专辑，是很多人的入坑曲，我一听也就喜欢了15年罢了。这首歌也是我心中最完美的一曲。30秒的前奏已然封神，风声 山谷 神秘 优雅，悦耳的旋律，东方特质的音阶，短短的时间内塞入了那么多的内容，不仔细听，根本不知道这首歌有多用心。《七里香》这首歌是当时的首播主打，很多人听到的时候同时看了MV，我觉得这是周杰伦所有歌的MV中把他拍的最帅的一个MV了，灯光的照耀下，脸部轮廓立体。MV在日本拍头文字D时取的景，这个MV拍的让我印象很深。整个歌词也是一首现代诗，表达了夏天 田园等主题，和陶渊明的采菊东篱下悠然见南山有些气息相通，不过陶渊明谈的是志趣，方文山谈爱情，退下庙堂，回归田园，眼前的生活只剩下雨水落叶和思念，才能毫不掩饰的把爱慕女孩的脸形容成田里熟透的番茄，很打动人。不过现在听到这首歌有点忧伤，这首歌已经是演唱会的ending歌曲了，全场大合唱，让人很感动。“你是我唯一想要的了解” 园游会 园游会虽然是在磁带的B面哈，但是我要提前说了，因为这首歌对我意味着太多太多，这首歌简直是恋爱的催化剂啊有没有，第一次听就被旋律所吸引，也是一首很甜的歌，我现在的闹钟铃声还是园游会，让我早上起来就甜甜的，开始美美的一天。恋爱是让人快乐的事，如果不快乐，为何还要恋爱呢？“你没有化妆我却疯狂爱上”，无法掩饰方文山情感老手的身份，这可不是青少年时期暗恋自己最喜欢的女同学那个级别，而是经历过很多化妆女孩后的那种返璞归真。男人用眼睛恋爱，女人用心恋爱，《园游会》又用眼睛又用心，草地，入场券，捞鱼，气球，都是充满了恋爱的酸臭。。让人听了有恋爱的冲动。刚刚说了这首歌对我意味很多，我曾经遇到了一个女孩，她没有化妆我却疯狂爱上，我能够牢记她的气质和脸庞，在一起看电影看到恐怖或刺激的时候，在一起抓娃娃的时候，一起坐电梯的时候，我安静的欣赏她慌乱的模样；我顶着大太阳 却在为她撑伞，一起逛街压马路走到半夜话题总是不断，对你表白的时候，你装忙的眼神，曾经约好这个世界一起逛。。。一切都像歌词里说的那样，那么甜，我曾经对你说，这首歌适合表白，而最后我用这首歌的歌词宣布了恋情。。。一切的一切是那么美好，可是。。。。。。 借口 （施工中，未完待续） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-09-24 22:15:53 "}}