{"./":{"url":"./","title":"写在前面","keywords":"","body":"前言 欢迎来到Gary的小窝 这里记录着自己学习成长的点点滴滴和生活的碎碎念 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/":{"url":"leetcode/","title":"Leetcode之旅","keywords":"","body":" LeetCode LeetCode是个题库，里面有很多编程面试的算法题目，可以在线编译运行。 在这里，你可以使用 C、C++、Java、Python、PHP、JavaScript 等共 14 种编程语言进行解题。 本系列文章会记录自己使用JavaScript语言去解答每道题的过程，持续更新 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/1.html":{"url":"leetcode/1.html","title":"1.两数之和","keywords":"","body":" 001. 两数之和 一 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例： 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 二 解题过程 拿到题目很容易想到数组循环遍历判断，于是我三下五除二写出了这样的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { if(!nums instanceof Array){ return; } for(let i = 0 ; i 使用双层循环去遍历数组，如果找的到就返回索引值，这个算法的复杂度是O（n2）. 我满怀欣喜的提交代码去验证答案，得到的结果是通过，但是复杂度有些过高了,内存占也有点大 内存消耗 :34.7 MB, 在所有 JavaScript 提交中击败了41.93%的用户 所以我苦思冥想，可不可以不用二次循环的方式解题。于是我想到了 indexOf indexOf()：判断数组中是否存在判断条件中的值。如果存在，则返回第一次出现的索引；如果不存在，则返回 -1。 于是就会有了下面的代码 /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var twoSum = function(nums, target) { let result = []; nums.map((item, index) => { if (nums.indexOf(target - item) > -1 && nums.indexOf(target - item) != index) { result = [index, nums.indexOf(target - item)].sort((a, b) => a > b); } }); return result; }; 通过遍历一次数组 ，使用 indexOf() 寻找除当前 item 的 index 之外和 item 相加之和为 target 的结果。 最后，我们返回查找的最新结果，该结果进行了排序（[4, 2] 的返回通过 sort() 排序变成 [2, 4]） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/2.html":{"url":"leetcode/2.html","title":"2.两数相加","keywords":"","body":" 002. 两数相加 一 题目描述 给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 二 解题过程 这个题目是用一段程序把人在大脑中如何进行的加法计算出来。单链表中每一个节点的数据结构，其实是一个对象，val属性是表示当前节点的值，next属性是表示下一个节点。就像这样 function ListNode(val) { this.val = val; this.next = null; } 单链表的相加比较麻烦，这道题可以把2个单链表转化成数组 然后进行数组中每个元素相加的操作。然后把最后的数组 转化成一个链表的数据结构。代码如下 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { if(!l1){ return l2; } if(!l2){ return l1; } //把链表转成数组 var arr1 = []; var arr2 = []; var res = []; while(l1){ arr1.push(l1.val); l1=l1.next; } while(l2){ arr2.push(l2.val); l2=l2.next; } //此时arr1 和arr2 就转化成了数组 //数组的每一个位数的相加，jdg 表示进位，如果两个数相加大于9 就要进行进位操作+1 //把最后的结果push 到新数组中 var jdg=false,newArr=[],sum=null,num=null, len=Math.max(arr1.length,arr2.length); for(var i = 0 ; i =10); newArr.push(num); } //如果第一位还是有进位 push 1 if(jdg){ newArr.push(1); } //将返回的数字转成链表 var result = newArr; var node={ val:null, next:null }, head = node; for(i=0;i 提交成功， 内存消耗 :39.5 MB, 在所有 JavaScript 提交中击败了11.87%的用，优化方案苦思冥想中。。。 to be continued Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/3.html":{"url":"leetcode/3.html","title":"3.无重复字符的最长子串","keywords":"","body":" 003. 无重复字符的最长子串 一 题目描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 例如： 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 二 解题过程 这道题还是比较有思路的，要找出没有重复的最长子串，就只需要遍历这个字符串 然后用数组维护一个队列，当遍历出的字符 不存在这个队列中时候，就push进 这个数组 当这个字符存在于这个队列中的时候，就‘先进先出’ 把第一个字符删除 然后继续遍历这个字符串 /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function(str) { let arr = [] let res = 0; let i = 0; while(i Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/4.html":{"url":"leetcode/4.html","title":"4.寻找两个有序数组的中位数","keywords":"","body":" 004. 寻找两个有序数组的中位数 一 题目描述 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 例如： nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 二 解题过程 2个有序的数组 找中位数 其实思路就是把两个数组 合并成一个有序的数组 再求中位数 。如果这个数组的个数是奇数 那么中位数就是中间的那个数 否则就是2个中间的值除2 /** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number} */ var findMedianSortedArrays = function(nums1, nums2) { var arr= nums1.concat(nums2).sort((a, b) => a - b); const { length } = arr; return length % 2 ? arr[Math.floor(length / 2)] : (arr[length / 2] + arr[length / 2 - 1]) / 2; }; 执行用时 :212 ms, 在所有 JavaScript 提交中击败了46.94%的用户 内存消耗 :39.8 MB, 在所有 JavaScript 提交中击败了32.79%的用户 洋洋洒洒几行代码 但是这明显不是最优解 JS内部提供的排序算法sort 内部是使用快速排序和插入排序算法 时间复杂度 都是O（log2n） Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/6.html":{"url":"leetcode/6.html","title":"6.Z字形变换","keywords":"","body":" 006. Z字型变换 一 题目描述 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例1： 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例2： 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G 二 解题过程 首先想到就是使用队列。几行就要用几个队列的形式把字符串按照方式插入队列最后再一起循环遍历出来。 1.首先用数组的形式，每一项就是一个字符串代表每个队列。 2.遍历字符串，用是否向下的标记 标记遍历的方向， 当行数 = 0 或者 length-1的时候需要转向。 3.最后把几个队列合并成一个字符串 /** * @param {string} s * @param {number} numRows * @return {string} */ var convert = function(s, numRows) { if(numRows == 1){ return s; } var arr = []; var len = Math.min(s.length,numRows); for(var i = 0; i Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/9.html":{"url":"leetcode/9.html","title":"9.回文数","keywords":"","body":" 009. 回文数 一 题目描述 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例1： 输入: 121 输出: true 示例2： 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例3： 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 二 解题过程 判断回文数，就是判断从前往后遍历到中位数的值 和从后往前遍历 所得的数相同。数字可以通过遍历，不断的整除10，得到从前往后的数字， 通过%10 得到剩余的最后一位的值 把后面的值组合起来和前面遍历的值进行比较 得到true 或者false 注意数字的个数 是奇数 和偶数的情况，判断有所不同。 /** * @param {number} x * @return {boolean} */ var isPalindrome = function(x) { if(x revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x = Math.floor(x / 10); } return x == revertedNumber || x == Math.floor(revertedNumber / 10) }; 坑： Java当中的整除 和JavaScript 中不一样。 Java中直接用 a/b 得到的就是整除。 JS中不同，得用 Math.floor(revertedNumber / 10) 这种方式 才行， 遗忘了。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/11.html":{"url":"leetcode/11.html","title":"11.盛最多水的容器","keywords":"","body":" 011. 盛最多水的容器 一 题目描述 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2 示例1： 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 二 解题过程 双指针解法。 在数组的最左边 和最右边 做标记，计算他们的乘积，容纳的水 是以小的那个值为单位，乘以 两个标记之间的值。 每次两个指针总是 小的值朝大的值 方向移动一个 一直循环 直到两个指针碰头。 最后计算的最大值 就是结果 /** * @param {number[]} height * @return {number} */ var maxArea = function(height) { var max = 0; var left = 0; var right = height.length -1; while(left Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/12.html":{"url":"leetcode/12.html","title":"12.整数转罗马数字","keywords":"","body":" 012. 整数转罗马数字 一 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例1： 输入: 3 输出: \"III\" 示例2： 输入: 4 输出: \"IV\" 示例3： 输入: 9 输出: \"IX\" 示例4： 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例5： 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 二 解题过程 思路还是比较清晰的 把每位数字 取出来 根据不同情况判断 是否是4 或者是5或者9 转换成罗马数字 最后拼成一个字符串 /** * @param {number} num * @return {string} */ var intToRoman = function(num) { // 输入的数字在1到3999 范围内 if(num > 3999 || num 0){ for(var i = 0 ; i 0 && hundred 4 && hundred0 && ten 4 && ten0 && one 4 && one 三 思考 上述解法是比较暴力的 当我查看了官方题解后，发现了一种新的解法，贪心算法。 四 贪心算法 在生活中的例子： 在以前还使用现金购物的年代，如果我们不想让对方找钱，付款的时候我们会尽量拿面值大的纸币给对方，这样才会使得我们给对方的纸币张数最少，对方点钱的时候（因为对方要检验你给的钱对不对）也最方便。最极端的一种情况，你要是都拿零钱去买一个比较贵重的东西，我相信没有人是很高兴收到你的钱的，因为他们点钱费劲。 整数转罗马数字”与上面的问题是一模一样的思想：在表示一个较大整数的时候，“罗马数字”不会让你都用 11 加起来，肯定是写出来的“罗马数字”的个数越少越好。 于这道问题，“纸币”有哪些，并不是只有题目中给出的对应关系，根据规则，还可以得到一些“纸币”的面值，不过都是有限个“纸币”，很快就能罗列出来。 于是解这道题的思路就出来了： “纸币”有哪些？ 一个整数如何做“加法因子”的分解？ 思路分析： 从题目中给出的“罗马数字”与阿拉伯数字的对应关系，和翻译规则，我们需要推导出“罗马数字”还有哪些组合。 罗马数字 阿拉伯数字 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 为此，我们要举例子帮助我们发现规律： 阿拉伯数字 转换规则 罗马数字 1 直接看表 I 2 2=1+1，相同数字简单叠加 II 3 3=1+1+1，相同数字简单叠加 III 4 不能写成 4 = 1 + 1 + 1 + 14=1+1+1+1，44 应该看做 4 = 5 - 14=5−1 IV 5 直接看表 V 6 6=5+1，大数字在前，小数字在后 VI 7 7=5+1+1，大数字在前，小数字在后，相同数字简单叠加 VII 8 8=5+1+1+1，大数字在前，小数字在后，相同数字简单叠加 VIII 9 不能写成 9 = 5 + 1 + 1 + 1 + 19=5+1+1+1+1，99 应该看做 9 = 10 - 19=10−1 IX 10 直接看表 X 于是，我们发现（其实在题目中已经强调了这些特例），出现 44、99、4040、9090、400400、900900 （40004000、90009000 不讨论了，题目测试用例中有说，不会超过 39993999）的情况比较特殊一些，做的是减法，把它们也加入到“罗马数字”与阿拉伯数字的对应关系表中，并且按照从大到小的顺序排列。 罗马数字 阿拉伯数字 M 1000 CM 900 D 500 CD 400 C 100 XC 90 L 50 XL 40 X 10 IX 9 V 5 IV 4 I 1 于是，“将整数转换为阿拉伯数字”的过程，就是我们用上面这张表中右边的数字作为“加法因子”去分解一个整数，并且分解的整数个数越少越好，即尽量使用靠前的数字，这可以认为是一种贪心法则。 var intToRoman = function(num) { var nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1] var romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"] var index = 0 var res = '' while (index nums[index] || num == nums[index]){ res += romans[index] num -= nums[index] } index += 1 } return res }; Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/13.html":{"url":"leetcode/13.html","title":"13.罗马数字转整数","keywords":"","body":"013. 罗马数字转整数 一 题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例1： 输入: \"III\" 输出: 3 示例2： 输入: \"IV\" 输出: 4 示例3： 输入: \"IX\" 输出: 9 示例4： 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例5： 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 二 解题过程 在12题中，使用到了贪心算法 来解决数字和罗马字符之间的转换问题 我们同样可以使用这个思想来进行罗马字符和数字之间的转换。 /** * @param {string} s * @return {number} */ var romanToInt = function(s) { var nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; var romans = [\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"]; var number = 0; var index = 0; var str = s; while (index Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"leetcode/14.html":{"url":"leetcode/14.html","title":"14.最长公共前缀","keywords":"","body":"014. 最长公共前缀 一 题目描述 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例1： 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例2： 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明 所有输入只包含小写字母 a-z 。 二 解题过程 这题还是比较简单的，数组中取一项 与数组中所有项进行比较，如果这个字符串在数组中其他项中都存在IndexOf = 0 那么表明 最终的字符串就是那一项 ，否则 删除最后一个字符 进行循环比较 最后剩下的那个字符串 就是结果，如果不存在 则为'' /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { if(strs.length == 0){ return '' } //取数组第一项 进行比较 var min = strs[0]; //符号位 判断是否满足 所有项 的前缀 var bool = false; while(bool != true){ bool = strs.every(function(item){ return item.indexOf(min) == 0 }) // 不满足 则 去掉 最后一位 进行循环比较 if(!bool){ min=min.substring(0,min.length-1) } if(min == ''){ bool = true; } } return min; }; Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"flutter/":{"url":"flutter/","title":"Flutter从入门到放弃","keywords":"","body":"Flutter flutter是Google的移动UI框架，可以快速的在iOS和Android上构建高质量的源生用户界面。Flutter可以与现有的代码一起工作。在全世界，flutter正在被越来越多的开发者和组织使用，并且是免费，开源的。 在本系列中会记录学习Flutter的过程。参考了官方文档和《Fluuter技术与入门实践》这本书。 本系列会省略一些环境搭建的介绍，详细介绍见官方文档 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"flutter/dart1.html":{"url":"flutter/dart1.html","title":"1.Dart语言(1)","keywords":"","body":"Dart语言 1.Dart重要概念 Dart语言是Google在2011年10月在丹麦举行的Goto会议上宣布，是一种结构化的web编程语言，因为Dart语言拥有一些特性，例如： AOT编辑，JIT编辑，可以轻松的创建60fps运行的流畅动画和转场。不需要单独的声明式布局语言，易学习等特点。 这使得Flutter 使用了Dart这个语言 成为其开发语言。Dart拥有几个概念： 所有东西都是对象，所有的对象都继承自内置的Object类。 程序中指定数据类型使得程序合理的分配内存空间，并且帮助编译器进行语法检查。但是，指定类型不是必须的。Dart 是弱类型语言。 Dart代码在运行前解析。 Dart程序有统一的入口 main() 这一点和C C++ 很像。 Dart语言没有public protected 和 private 的概念。 私有特性 通过 变量 或者函数 加上下划线表示。 Dart语言支持async/await 异步处理 变量 基本数据类型 var声明变量 类似于kotlin,JS中的var，它可以接收任何类型的变量，但最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型，如： var t; t=\"yc\"; // 下面代码在dart中会报错，因为变量t的类型已经确定为String， // 类型一旦确定后则不能再更改其类型。 t=1000; 最大的不同是Dart中var变量一旦赋值，类型便会确定，则不能再改变其类型。因为Dart本身是一个强类型语言，任何变量都是有确定类型的，在Dart中，当用var声明一个变量后，Dart在编译时会根据第一次赋值数据的类型来推断其类型，编译结束后其类型就已经被确定。 变量 var num = 0; var title = \"标题\"; Dart 不需要给变量设置 setter getter 方法， 这和 kotlin 等类似。Dart 中所有的基础类型、类等都继承 Object ，默认值是 NULL， 自带 getter 和 setter ，而如果是 final 或者 const 的话，那么它只有一个 getter 方法。 常量 //final 表示常量 只能设定一次 final name = \"111\"; // name = '222' 会引发一个错误 //static const 组合代表了静态常量 static const String complete = \"COMPLETE\"; final和const区别 两者区别在于：const 变量是一个编译时常量，final变量在第一次使用时被初始化。被final或者const修饰的变量，并且变量类型可以省略。 基本数据类型 Dart语言的常用的基本数据类型包括： Number String Boolean List Map Number String Boolean 在JS中 很熟悉了。 用var 进行变量赋值的时候会推断成对应的类型 var num = 0; var title = \"标题\"; var mIsLogin = false; List 就是数组 ``` dart List arr1 = [1,2,3,4]; var arr2 = [1,2,3,4]; print(list); //Output: [1, 2, 3, 4] //Length 长度 print(list.length); //Selecting single value 获取单个值 print(list[1]); //Outout: 2 //Adding a value 添加值到list list.add(10); //Removing a single isntance of value 删除单个值 list.remove(3); //Remove at a particular position 删除指定位置的值 第一个元素索引是0，最后一个元素是length-1 list.removeAt(0); >Map ``` dart var map = { 'key1': 'value1', 'key2': 'value2', 'key3': 'value3' }; //Fetching the values 获取值 print(map['key1']); //Output: value1 print(map['test']); //Output: null //Add a new value 添加值 map['key4'] = 'value4'; //Length 获取长度 print(map.length); //Check if a key is present 检查是否存在 var containsKey = map.containsKey('value1'); print(containsKey); var entries = map.entries; var values = map.values; 也可以使用map构造函数定义map。 var squares = new Map(); squares[\"a\"] = 1; squares[\"b\"] = 2; squares[\"c\"] = 3.0; squares[\"d\"] = [1,2]; squares[\"e\"] = \"yc逗比\"; print(squares['a']); print(squares['e']); 函数 dart中的函数和JavaScript中有点类似。你需要定义就是函数的名字、返回值(有返回值或者void)、参数。 void test(){ var name = fullName('杨充', '逗比'); print(name); } String fullName(String firstName, String lastName) { return \"$firstName $lastName\"; } 参数默认值 你可以给函数的命名参数一个默认值。下面的例子给lastName一个默认值。 void test(){ var name = fullName('杨充', '逗比'); print(name); } fullName(String firstName, String lastName) { return \"$firstName $lastName\"; } void无返回值 大多数都是void无返回值的函数，这个跟java中类似。没什么好讲的…… 匿名函数 在dart中函数比较灵活，例如，你可以将函数当参数传递给另一个函数。 void test(){ out(printOutLoud); } out(void inner(String message)) { inner('Message from inner function'); } printOutLoud(String message) { print(message.toUpperCase()); } 这里定义一个函数名字为out,需要一个函数参数。然后我定义一个名为printOutLoud的函数，他所做的就是将字符串以大写的形式打印。 dart 也有匿名函数，所以上面的例子中不用预定一个函数，而是传递一个匿名函数。 运算符 和java js 语言类似 不再赘述 流程控制 大概有这么多 很多都和JS 相同 if和elsevar number = 57; if (number > 100) { print('Large Number'); } else if (number for循环 ``` dart void test() { for (int i = 0; i print('$i'); } } * while循环 ``` dart void test() { int i = 0; while(i break和continue switch和casevoid test() { int age = 50; switch(age) { case 10: print('Too Young.'); break; case 20: case 30: print('Still Young!'); break; case 40: print('Getting old.'); break; case 50: print('You are old!'); break; } } assert断言 Dart语言中的异步 Future介绍 async 库中有一个叫Future的东西。Future是基于观察者模式的。如果你熟悉Rx或者JavaScript的Promises，你就很容易明白了。 首先先看一下下面的案例，看看它们之间有什么区别？ void testA() async{ new Future(() { return \"This is a doubi\"; }); } Future testB() async{ return new Future(() { return \"This is a doubi\"; }); } Future testC() { return new Future(() { return \"This is a doubi\"; }); } 普通异步案例 Future是支持泛型的，例如Future,通过T指定将来返回值的类型。 定义了一个叫getTest的函数，返回值为Future.你可以通过new关键字创建一个Future。Future的构造函数，需要一个函数作为参数，这个函数返回T类型的数据。在匿名函数中的返回值就是Future的返回值。 当调用了getTest方法，他返回Future.我们通过调用then方法订阅Future，在then中注册回调函数，当Future返回值时调用注册函数。同时注册了catchError方法处理在Future执行之间发生的异常。这个例子中不会发生异常。 ``` dart void test() { getTest().then((value) { print(\"测试----------\"+value); }).catchError((error) { print('测试----------Error'); }); } Future getTest() { return new Future(() { return \"This is a doubi\"; }); } //打印结果 2019-06-21 17:11:12.941 16501-16583/com.hwmc.auth I/flutter: 测试----------This is a doubi * 下面这个案例会发生异常 ``` dart void test() { getTest().then((value) { print(\"测试----------\"+value); }).catchError((error) { print('测试----------Error'); }); } Future getTest() { return new Future(() { return \"This is a doubi\"; }); } //打印结果 2019-06-21 17:18:46.896 16501-16583/com.hwmc.auth I/flutter: 测试----------Error 耗时异步案例 在生产环境中都是一些耗时的操作，例如，网络调用，我们可以使用Future.delayed()模仿。 现在如果你运行，你将需要2秒，才能返回结果。 ``` dart void test() { getTest().then((value) { print(\"测试----------\"+value); }).catchError((error) { print('测试----------Error'); }); } Future getTest() { return new Future.delayed(new Duration(milliseconds: 2000),() { return \"This is a doubi\"; }); } * 接下来再看一个案例。在调用函数之后，我们添加了print语句。在这种场景中，print语句会先执行，之后future的返回值才会打印。这是future的预期行为.但是如果我们希望在执行其他语句之前，先执行future。 ``` dart void test() { getTest().then((value) { print(\"测试----------\"+value); }).catchError((error) { print('测试----------Error'); }); print('测试----------逗比是这个先执行吗'); } Future getTest() { return new Future.delayed(new Duration(milliseconds: 2000),() { return \"This is a doubi\"; }); } 2019-06-21 17:26:16.619 16501-16583/com.hwmc.auth I/flutter: 测试----------逗比是这个先执行吗 2019-06-21 17:26:17.176 16501-16583/com.hwmc.auth I/flutter: 测试----------This is a doubi Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-16 23:18:54 "},"flutter/dart2.html":{"url":"flutter/dart2.html","title":"2.Dart语言(2)","keywords":"","body":"Dart 面向对象 类的简单介绍 创建一个类和创建类的实例 ``` dart void test1(){ Dog d = new Dog(); } class Dog { } var cat = new Cat(\"逗比\", 12); class Cat { String name; int age; Cat(String name, int age) { this.name = name; this.age = age; } } ### 构造函数 普通构造函数 ``` dart var cat = new Cat(\"逗比\", 12); class Cat { String name; int age; Cat(String name, int age) { this.name = name; this.age = age; } } 命名构造函数 给构造函数提供了名称，这样做使得不同的构造函数变的更加清晰。 Map map = new Map(); map['name']= \"哈巴狗\"; map['age'] = 5; Dog d = new Dog.newBorn(map); class Dog { String name; int age; Dog(this.name, this.age); Dog.newBorn(Map json) { name = json['name']; age = json['age']; } } 继承 可以使用extends关键字继承其他的类。 Pug 类继承Dog类，通过super关键字调用Dog类的构造函数。 Pug p = new Pug('哈哈哈', 5); print(p.name); class Dog { String name; int age; Dog(this.name, this.age); Dog.newBorn() { name = 'Doggy'; age = 0; } } class Pug extends Dog { Pug(String name, int age): super(name, age); } 也可以通过this关键字，在冒号之后调用同一个类中的其他构造函数。 定义了两个命名构造函数，他们只需要dog的名字，然后调用Pug的默认构造函数 Pug p = new Pug.small('哈哈哈'); print(p.name); class Dog { String name; int age; Dog(this.name, this.age); Dog.newBorn() { name = '逗比'; age = 0; } } class Pug extends Dog { Pug(String name, int age): super(name, age); Pug.small(String name): this(name, 1); Pug.large(String name): this(name, 3); } 重载和重写 方法重写 代码如下，最后打印值是：你真是个逗比 Pug p = new Pug(); print(p.bark()); class Dog { bark() { print('Bow Wow'); } } class Pug extends Dog { @override bark() { print('你真是个逗比!'); } } 抽象类 可以通过abstract关键字声明抽象类 只需要在类声明前添加abstract关键字，方法不需要。方法只需要签名，不需要实现。 ``` dart abstract class AbstractDog { void eat(); void _hiddenMethod(); } class SmallDog extends AbstractDog{ @override void _hiddenMethod() { } @override void eat() { } } ### 访问权限 * 默认类中的所有属性和方法是public的。在dart中，可以在属性和方法名前添加“_”使私有化。现在让我们使name属性私有化。 * 可以发现，调用私有化变量或者方法的时候会出现红色警告 ``` dart void test() { Dog d = new Dog('哈巴狗', 5); //这个报错 print(d.name); print(d.age); } Dog代码如下所示 class Dog { String _name; int age; Dog(this._name, this.age); String get respectedName { return 'Mr.$_name'; } set respectedName(String newName) { _name = newName; } Dog.newBorn() { _name = '哈巴狗'; age = 0; } bark() { print('Bow Wow'); } _hiddenMethod() { print('I can only be called internally!'); } } 静态方法 如果想让方法或者属性静态化，只需要在声明前添加static关键字。 void test() { Dog.bark(); } class Dog { static bark() { print('Bow Wow'); } } 泛型 dart全面支持泛型。假设你想在你定义的类中，想持有任意类型的数据。 DataHolder dataHolder = new DataHolder('Some data'); print(dataHolder.getData()); dataHolder.setData('New Data'); print(dataHolder.getData()); //下面这个会报错，因为dataHolder对象在创建的时候就已经限制为String类型 dataHolder.setData(123); print(dataHolder.getData()); class DataHolder { T data; DataHolder(this.data); getData() { return data; } setData(data) { this.data = data; } } async/await介绍 思考一下，看了上面的案例，对于future的预期行为，如果我们希望在执行其他语句之前，先执行future，该怎么操作呢？ 这就需要用到需要用到async/await。在test函数的花括号开始添加async关键字。我们添加await关键字在调用getTest方法之前，他所做的就是在future返回值之后，继续往下执行。我们将整个代码包裹在try-catch中，我们想捕获所有的异常，和之前使用catchError回调是一样。使用awiat关键字，必须给函数添加async关键字，否则没有效果。 注意：要使用 await，其方法必须带有 async 关键字。可以使用 try, catch, 和 finally 来处理使用 await 的异常！ Future test() async { try { String value = await getTest(); print(\"测试----------\"+value); } catch(e) { print('测试----------Error'); } print('测试----------逗比是这个先执行吗'); } Future getTest() { return new Future.delayed(new Duration(milliseconds: 2000),() { return \"This is a doubi\"; }); } 2019-06-21 17:32:37.701 16501-16583/com.hwmc.auth I/flutter: 测试----------This is a doubi 2019-06-21 17:32:37.702 16501-16583/com.hwmc.auth I/flutter: 测试----------逗比是这个先执行吗 看一个案例 一个 async 方法 是函数体被标记为 async 的方法。 虽然异步方法的执行可能需要一定时间，但是 异步方法立刻返回 - 在方法体还没执行之前就返回了 void getHttp async { // TODO --- } 在一个方法上添加 async 关键字，则这个方法返回值为 Future。 例如，下面是一个返回字符串的同步方法： String loadAppVersion() => \"1.0.2\" 使用 async 关键字，则该方法返回一个 Future，并且 认为该函数是一个耗时的操作。 Futre loadAppVersion() async => \"1.0.2\" 注意，方法的函数体并不需要使用 Future API。 Dart 会自动在需要的时候创建 Future 对象。 好的代码是这样的 void main() { //调用异步方法 doAsync(); } // 在函数上声明了 async 表明这是一个异步方法 Future doAsync() async { try { // 这里是一个模拟请求一个网络耗时操作 var result = await getHttp(); //请求出来的结果 return printResult(result); } catch (e) { print(e); return false; } } //将请求出来的结果打印出来 Future printResult(summary) { print(summary); } //开始模拟网络请求 等待 5 秒返回一个字符串 getHttp() { return new Future.delayed(Duration(seconds: 5), () => \"Request Succeeded\"); } 不好的写法 void main() { doAsync(); } Future doAsync() async { return getHttp().then((r){ return printResult(r); }).catchError((e){ print(e); }); } Future printResult(summary) { print(summary); } Future getHttp() { return new Future.delayed(Duration(seconds: 5), () => \"Request Succeeded\"); } Dart异常捕获 异常处理形式 dart 使用经典的try-catch处理异常，使用关键字throw抛出一个异常。 void test1(){ divide(10, 0); } divide(int a, int b) { if (b == 0) { throw new IntegerDivisionByZeroException(); } return a / b; } 当b变量的值为0的时候，抛出一个内置的异常IntegerDivisionByZeroException。 如何定义异常日志呢？ 可以在异常中携带一个字符串信息。 void test1(){ divide(10, 0); } divide(int a, int b) { if (b == 0) { throw new Exception('逗比，不能为0的'); } return a / b; } 捕获异常 某种类型的异常可以通过on关键字捕获，如下： void test1(){ try { divide(10, 0); } on IntegerDivisionByZeroException { print('逗比，异常被捕获了'); } } divide(int a, int b) { if (b == 0) { throw new IntegerDivisionByZeroException(); } return a / b; } 注意问题，捕获的异常层级要大于抛出的异常，否则捕获会失败 还是会抛出异常'逗比，不能为0的'，因为Exception比IntegerDivisionByZeroException层级要高 void test1(){ try { divide(10, 0); } on IntegerDivisionByZeroException { print('逗比，异常被捕获了'); } } divide(int a, int b) { if (b == 0) { throw new Exception('逗比，不能为0的'); } return a / b; } 如果你不知道抛出异常的类型，或者不确定，可以使用catch块处理任意类型的异常。 void test1(){ try { divide(10, 0); } on IntegerDivisionByZeroException { print('逗比，异常被捕获了'); } catch (e) { print(e); } } divide(int a, int b) { if (b == 0) { throw new Exception('yc other exception.'); } return a / b; } Finally讲解 dart也提供了finally块，即是否发生异常这个块都会执行。 void test1(){ try { divide(10, 0); } on IntegerDivisionByZeroException { print('逗比，异常被捕获了'); } catch (e) { print(e); }finally { print('I will always be executed!'); } } divide(int a, int b) { if (b == 0) { throw new Exception('yc other exception.'); } return a / b; } Dart枚举 枚举使用 dart 支持枚举，用法和java一样。 Dog d = new Dog('哈巴狗', 12, CurrentState.sleeping); print(d.state == CurrentState.sleeping); //Prints 'true' enum CurrentState { sleeping, barking, eating, walking } class Dog { String name; int age; CurrentState state; Dog(this.name, this.age, this.state); static bark() { print('Bow Wow'); } } 元数据 使用元数据给代码添加额外信息，元数据注解是以@字符开头，后面是一个编译时常量或者调用一个常量构造函数。 有三个注解所有的Dart代码都可使用：@deprecated、@override，@proxy, 元数据可以在library、typedef、type parameter、constructor、factory、function、field、parameter、或者variable声明之前使用，也可以在import或者export指令之前使用，使用反射可以再运行时获取元数据信息。 自定义注解 定义自己的元数据注解。下面的示例定义一个带有两个参数的@toDo注解： void test1() { doSomething(); } @toDo('seth', 'make this do something') void doSomething() { print('do something'); } class toDo { final String who; final String what; const toDo(this.who, this.what); } Dart 字符串 String简单介绍 Dart字符串是UTF-16编码的字符序列，可以使用单引号或者双引号来创建字符串： String str1 = '单引号字符串'; String str2 = \"双引号字符串\"; print(str1); //输出：单引号字符串 print(str2); //输出：双引号字符串 单双引号互相嵌套 String中单、双引号互相嵌套情况如下所示 String str1 = '单引号中的\"双引号\"字符串'; String str2 = \"双引号中的'单引号'字符串\"; print(\"yc-str1--\" + str1); print(\"yc-str2--\" + str2); //单引号里面有单引号，必须在前面加反斜杠 String str3 = '单引号中的\\'单引号\\''; String str4 = \"双引号里面有双引号,\\\"双引号\\\"\"; print(\"yc-str3--\" + str3); print(\"yc-str4--\" + str4); 注意点:： 单引号嵌套单引号之间不允许出现空串（不是空格），双引号嵌套双引号之间不允许出现空串： //String str5 = '单引号''''单引号'; //报错了，逗比 String str6 = '单引号'' ''单引号'; String str7 = '单引号''*''单引号'; String str8 = \"双引号\"\" \"\"双引号\"; String str9 = \"双引号\"\"*\"\"双引号\"; //String str10 = \"双引号\"\"\"\"双引号\"; //报错了，逗比 print(\"yc-str6--\" + str6); print(\"yc-str7--\" + str7); print(\"yc-str8--\" + str8); print(\"yc-str9--\" + str9); Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-17 00:02:01 "},"flutter/chapter2.html":{"url":"flutter/chapter2.html","title":"3.Flutter 技术总结","keywords":"","body":"Flutter 技术总结 前言 结合官方文档和《Fluuter技术与入门实践》书籍 详细阐述Flutter技术，涉及Dart语言，Flutter Widget，Flutter状态管理等。 Flutter 是什么 Flutter is Google’s UI toolkit for building beautiful, natively compiled applications for mobile, web, and desktop from a single codebase. Flutter是由原 Google Chrome 团队成员，利用 Chrome 2D 渲染引擎，然后精简 CSS 布局演变而来。架构图如下图 Flutter 在各个原生的平台中，使用自己的 C++的引擎渲染界面，没有使用 webview，也不像 RN、NativeScript 一样使用系统的组件。简单来说平台只是给 Flutter 提供一个画布。 界面使用 Dart 语言开发，貌似唯一支持 JIT（Just-In-Time），和 AOT （Ahead-Of-Time）模式的强类型语言。 写法非常的现代，声明式，组件化，Composition > inheritance，响应式……就是现在前端流行的这一套 :smile: 一套代码搞定所有平台。 Flutter 为什么快？Flutter 相比 RN 的优势在哪里？ 从架构中实际上已经能看出 Flutter 为什么快，至少相比之前的当红炸子鸡 React Native 快的原因了。 Skia 引擎，Chrome， Chrome OS，Android，Firefox，Firefox OS 都以此作为渲染引擎。 Dart 语言可以 AOT 编译成 ARM Code，让布局以及业务代码运行的最快，而且 Dart 的 GC 针对 Flutter 频繁销毁创建 Widget 做了专门的优化。 CSS 的子集 Flex like 的布局方式，保留强大表现能力的同时，也保留了性能。 Flutter 业务书写的 Widget 在渲染之前 diff 转化成 Render Object，对，就像 React 中的 Virtual DOM，以此来确保开发体验和性能。 而相比 React Native： RN 使用 JavaScript 来运行业务代码，然后 JS Bridge 的方式调用平台相关组件，性能比有损失，甚至平台不同 js 引擎都不一样。 RN 使用平台组件，行为一致性会有打折，或者说，开发者需要处理更多平台相关的问题。 阿里巴巴旗下闲鱼技术团队是国内比较早使用Flutter的团队，他们对于Flutter技术写了很多干货文章，地址在这里 链接,关于Flutter和RN的性能测试，他们也写了一篇技术文章，可以看这里，结论是 Flutter，在 CPU，FPS，内存稳定上均优于 ReactNative。 Dart 语言 在开始 Flutter 之前，我们需要先了解下 Dart 语言 Dart 是由 Google 开发，最初是想作为 JavaScript 替代语言，但是失败沉寂之后，作为 Flutter 独有开发语言又焕发了第二春。 实际上即使到了 2.0，Dart 语法和 JavaScriptFlutter非常的相像。单线程，Event Loop…… Dart 相比于Flutter 有一些更甜的语法糖 不会飘的 this 强类型，当然前端现在有了 TypeScript 强大方便的操作符号： ?. 方便安全的 foo?.bar取值，如果 foo 为 null，那么取值为 null ?? condition?expr1:expr2 可以简写为 expr1??expr2 =和其他符号的组合: *=、 ~/=、 &=、 |= …… 级联操作符(Cascade notation ..) 比如 querySelect('#button') ..text =\"Confirm\" ..classes.add('important') ..onClick.listen((e) => window.alert('Confirmed')) 甚至可以重写操作符 class Vector { final int x, y; Vector(this.x, this.y); Vector operator +(Vector v) => Vector(x + v.x, y + v.y); Vector operator -(Vector v) => Vector(x - v.x, y - v.y); // Operator == and hashCode not shown. For details, see note below. // ··· } void main() { final v = Vector(2, 3); final w = Vector(2, 2); assert(v + w == Vector(4, 5)); assert(v - w == Vector(0, 1)); } 注：重写 ==，也需要重写 Object hashCodegetter class Person { final String firstName, lastName; Person(this.firstName, this.lastName); // Override hashCode using strategy from Effective Java, // Chapter 11. @override int get hashCode { int result = 17; result = 37 * result + firstName.hashCode; result = 37 * result + lastName.hashCode; return result; } // You should generally implement operator == if you // override hashCode. @override bool operator ==(dynamic other) { if (other is! Person) return false; Person person = other; return (person.firstName == firstName && person.lastName == lastName); } } void main() { var p1 = Person('Bob', 'Smith'); var p2 = Person('Bob', 'Smith'); var p3 = 'not a person'; assert(p1.hashCode == p2.hashCode); assert(p1 == p2); assert(p1 != p3); } 这点在 diff 对象的时候尤其有用。 lsolate Dart 运行在独立隔离的 iSolate 中就类似 JavaScript 一样，单线程事件驱动，但是 Dart 也开放了创建其他 isolate，充分利用 CPU 的多和能力。 loadData() async { // 通过spawn新建一个isolate，并绑定静态方法 ReceivePort receivePort =ReceivePort(); await Isolate.spawn(dataLoader, receivePort.sendPort); // 获取新isolate的监听port SendPort sendPort = await receivePort.first; // 调用sendReceive自定义方法 List dataList = await sendReceive(sendPort, 'https://hicc.me/posts'); print('dataList $dataList'); } // isolate的绑定方法 static dataLoader(SendPort sendPort) async{ // 创建监听port，并将sendPort传给外界用来调用 ReceivePort receivePort =ReceivePort(); sendPort.send(receivePort.sendPort); // 监听外界调用 await for (var msg in receivePort) { String requestURL =msg[0]; SendPort callbackPort =msg[1]; Client client = Client(); Response response = await client.get(requestURL); List dataList = json.decode(response.body); // 回调返回值给调用者 callbackPort.send(dataList); } } // 创建自己的监听port，并且向新isolate发送消息 Future sendReceive(SendPort sendPort, String url) { ReceivePort receivePort =ReceivePort(); sendPort.send([url, receivePort.sendPort]); // 接收到返回值，返回给调用者 return receivePort.first; } 当然 Flutter 中封装了compute，可以方便的使用，譬如在其它 isolate 中解析大的 json。 Dart UI as Code 在这里单独提出来的意义在于，从 React 开始，到 Flutter，到最近的 Apple SwiftUI，Android Jetpack Compose 声明式组件写法越发流行，Web 前端使用 JSX 来让开发者更方便的书写，而 Flutter，SwiftUI 则直接从优化语言本身着手。 函数类的命名参数 void test({@required int age,String name}) { print(name); print(age); } // 解决函数调用时候，参数不明确的问题 test(name:\"hicc\",age: 30) // 这样对于组件的使用尤为方便 class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(), body: Container(), floatingActionButton:FloatingActionButton() ); } } 大杀器：Collection If 和 Collection For // collection If Widget build(BuildContext context) { return Row( children: [ IconButton(icon: Icon(Icons.menu)), Expanded(child: title), if (!isAndroid) IconButton(icon: Icon(Icons.search)), ], ); } // Collect For var command = [ engineDartPath, frontendServer, for (var root in fileSystemRoots) \"--filesystem-root=$root\", for (var entryPoint in entryPoints) if (fileExists(\"lib/$entryPoint.json\")) \"lib/$entryPoint\", mainPath ]; Flutter 怎么写 到这里终于到正题了，熟悉 React 的话，你会发现异常的熟悉。 UI=F(state) Flutter App 的一切从 lib/main.dart文件的 main 函数开始： import 'package:flutter/material.dart'; void main() => runApp(MyApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Welcome to Flutter', home: Scaffold( appBar: AppBar( title: Text('Welcome to Flutter'), ), body: Center( child: Text('Hello World'), ), ), ); } } Dart 类 build 方法返回的便是 Widget，在 Flutter 中一切都是 Widget，包括但不限于 结构性元素，menu，button 等 样式类元素，font，color 等 布局类元素，padding，margin 等 导航 手势 Widget 是 Dart 中特殊的类，通过实例化(Dart 中new 是可选的)相互嵌套，你的这个 App 就是形如下图的一颗组件树(Dart 入口函数的概念， main.dart->main())。 Widget 布局 Flutter中万物皆Widget 最开始说过 Flutter 布局思路来自 CSS，而 Flutter 中一切皆 Widget，因此整体布局也很简单： 容器组件 Container decoration 装饰属性，设置背景色，背景图，边框，圆角，阴影和渐变等 margin padding alignment width height Padding，Center Row,Column,Flex Wrap, Flow 流式布局 stack， z 轴布局 。。。。。。 关于widget 更多可以查看咸鱼团队的文章 Flutter 中 Widget 可以分为三类，形如 React 中“展示组件”、“容器组件”，“context”。 StatelessWidget 这个就是 Flutter 中的“展示组件”，自身不保存状态，外部参数变化就销毁重新创建。Flutter 建议尽量使用无状态的组件。 StatefulWidget 状态组件就是类似于 React 中的“容器组件”了，Flutter 中状态组件写法会稍微不一样。 class Counter extends StatefulWidget { // This class is the configuration for the state. It holds the // values (in this case nothing) provided by the parent and used by the build // method of the State. Fields in a Widget subclass are always marked \"final\". @override _CounterState createState() => _CounterState(); } class _CounterState extends State { int _counter = 0; void _increment() { setState(() { // This call to setState tells the Flutter framework that // something has changed in this State, which causes it to rerun // the build method below so that the display can reflect the // updated values. If you change _counter without calling // setState(), then the build method won't be called again, // and so nothing would appear to happen. _counter++; }); } @override Widget build(BuildContext context) { // This method is rerun every time setState is called, for instance // as done by the _increment method above. // The Flutter framework has been optimized to make rerunning // build methods fast, so that you can just rebuild anything that // needs updating rather than having to individually change // instances of widgets. return Row( children: [ RaisedButton( onPressed: _increment, child: Text('Increment'), ), Text('Count: $_counter'), ], ); } } 可以看到 Flutter 中直接使用了和 React 中同名的 setState方法，不过不会有变量合并的东西，当然也有生命周期。 一个有状态的组件需要两个 Class，这样写的原因在于，Flutter 中 Widget 都是 immmutable 的，状态组件的状态保存在 State 中，组件仍然每次重新创建，Widget 在这里只是一种对组件的描述，Flutter 会 diff 转换成 Element，然后转换成 RenderObject 才渲染。 Flutter Widget 更多的渲染流程可以看这里。 State Management setState()可以很方便的管理组件内的数据，但是 Flutter 中状态同样是从上往下流转的，因此也会遇到和 React 中同样的问题，如果组件树太深，逐层状态创建就显得很麻烦了，更不要说代码的易读和易维护性了。 InheritedWidget 同样 Flutter 也有个 context一样的东西，那就是 InheritedWidget，使用起来也很简单。 class GlobalData extends InheritedWidget { final int count; GlobalData({Key key, this.count,Widget child}):super(key:key,child:child); @override bool updateShouldNotify(GlobalData oldWidget) { return oldWidget.count != count; } static GlobalData of(BuildContext context) => context.inheritFromWidgetOfExactType(GlobalData); } class MyApp extends StatelessWidget { // This widget is the root of your application. @override Widget build(BuildContext context) { return MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), home: MyHomePage(title: 'Flutter Demo Home Page'), ); } } class MyHomePage extends StatefulWidget { MyHomePage({Key key, this.title}) : super(key: key); final String title; @override _MyHomePageState createState() => _MyHomePageState(); } class _MyHomePageState extends State { int _counter = 0; void _incrementCounter() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: GlobalData( count: _counter, child: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: [ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.display1, ), Body(), Body2() ], ), ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), ); } } class Body extends StatelessWidget { @override Widget build(BuildContext context) { GlobalData globalData = GlobalData.of(context); return Text(globalData.count.toString()); } } class Body2 extends StatelessWidget { @override Widget build(BuildContext context) { // TODO: implement build GlobalData globalData = GlobalData.of(context); return Text(globalData.count.toString()); } 具体实现原理可以参考这里，不过 Google 封装了一个更为上层的库provider，具体使用可以看这里。 BlOC BlOC是 Flutter team 提出建议的另一种更高级的数据组织方式。简单来说： Bloc = InheritedWidget + RxDart(Stream) Dart 语言中内置了 Steam，Stream ~= Observable，配合RxDart, 然后加上 StreamBuilder会是一种异常强大和自由的模式。 class GlobalData extends InheritedWidget { final int count; final Stream timeInterval$ = new Stream.periodic(Duration(seconds: 10)).map((time) => new DateTime.now().toString()); GlobalData({Key key, this.count,Widget child}):super(key:key,child:child); @override bool updateShouldNotify(GlobalData oldWidget) { return oldWidget.count != count; } static GlobalData of(BuildContext context) => context.inheritFromWidgetOfExactType(GlobalData); } class TimerView extends StatelessWidget { @override Widget build(BuildContext context) { GlobalData globalData = GlobalData.of(context); return StreamBuilder( stream: globalData.timeInterval$, builder: (context, snapshot) { return Text(snapshot?.data ?? ''); } ); } } 当然 Bloc 的问题在于 学习成本略高，Rx 的概念要吃透，不然你会抓狂 自由带来的问题是，可能代码不如 Redux 类的规整。 今年 Apple 也拥抱了响应式，Combine(Rx like) + SwiftUI 也基本等于 Bloc 了。 所以，Rx 还是要赶紧学起来 除去 Bloc，Flutter 中还是可以使用其他的方案，譬如： Flutter Redux 阿里闲鱼的Fish Redux，据说性能很好。 Mobx …… 展开来说现在的前端开发使用强大的框架页面组装已经不是难点了。开发的难点在于如何组合富交互所需的数据，也就是上面图中的 state部分。 更具体来说，是怎么优雅，高效，易维护地处理短暂数据(ephemeral state) setState()和需要共享的 App State 的问题，这是个工程性的问题，但往往也是日常开发最难的事情了. 到这里，主要的部分已经总结完了，有这些已经可以开发出一个不错的 App 了。 测试 Flutter debugger，测试都是出场自带，用起来也不难。 // 测试在/test/目录下面 void main() { testWidgets('Counter increments smoke test', (WidgetTester tester) async { // Build our app and trigger a frame. await tester.pumpWidget(MyApp()); // Verify that our counter starts at 0. expect(find.text('0'), findsOneWidget); expect(find.text('1'), findsNothing); // Tap the '+' icon and trigger a frame. await tester.tap(find.byIcon(Icons.add)); await tester.pump(); // Verify that our counter has incremented. expect(find.text('0'), findsNothing); expect(find.text('1'), findsOneWidget); }); } 包管理，资源管理 类似与 JavaScript 的 npm，Flutter，也就是 Dart 也有自己的包仓库。不过项目包的依赖使用 yaml 文件来描述: name: app description: A new Flutter project. version: 1.0.0+1 environment: sdk: \">=2.1.0 生命周期 移动应用总归需要应用级别的生命周期，flutter 中使用生命周期钩子，也非常的简单： class MyApp extends StatefulWidget { @override _MyAppState createState() => new _MyAppState(); } class _MyAppState extends State with WidgetsBindingObserver { @override void initState() { super.initState(); WidgetsBinding.instance.addObserver(this); } @override void dispose() { WidgetsBinding.instance.removeObserver(this); super.dispose(); } @override void didChangeAppLifecycleState(AppLifecycleState state) { switch (state) { case AppLifecycleState.inactive: print('AppLifecycleState.inactive'); break; case AppLifecycleState.paused: print('AppLifecycleState.paused'); break; case AppLifecycleState.resumed: print('AppLifecycleState.resumed'); break; case AppLifecycleState.suspending: print('AppLifecycleState.suspending'); break; } super.didChangeAppLifecycleState(state); } @override Widget build(BuildContext context) { return Container(); } } Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-11-17 00:31:06 "},"ts/":{"url":"ts/","title":"TypeScript系列","keywords":"","body":"TypeScript学习并重写axios 本系列文章记录学习ts语法到实战的过程，最终希望实现用ts写axios库并发布 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"ts/1.html":{"url":"ts/1.html","title":"1.安装与上手","keywords":"","body":"安装TypeScript 使用npm来安装 npm install -g typescript 安装成功后在命令行输入 tsc -v 如果输出版本号 表示全局安装成功 第一行TypeScript代码 打开文本编辑工具 如vscode 新建hello.ts文件 function greeter(person) { return \"Hello, \" + person; } let user = \"Jane User\"; document.body.innerHTML = greeter(user); 在命令行上，运行TypeScript编译器： tsc hello.ts 输出结果为一个hello.js文件，它包含了和输入文件中相同的JavsScript代码。 一切准备就绪，我们可以运行这个使用TypeScript写的JavaScript应用了 体验类型注解 ts的类型注解 和swift，kotlin语言中很类似 ，它为函数或变量添加约束的方式。可以指定参数 变量的类型 在变量后用：加上类型名来表示，如： function greeter(person: string) { return \"Hello, \" + person; } 如果你给person 一个错误的类型 如 数组类型，在编译的时候就会报错: hello.ts(7,26): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'. 要注意的是尽管有错误，hello.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。 体验接口 ts中居然有类似Java的接口了。 我们可以使用接口来描述一个拥有某些固定字段的对象。在实现的时候并不是像Java那样实现implements语句，只要包含了接口要求的结构就可以。 interface Person { firstName: string; lastName: string; } function greeter(person: Person) { return \"Hello, \" + person.firstName + \" \" + person.lastName; } let user = { firstName: \"Jane\", lastName: \"User\" }; document.body.innerHTML = greeter(user); 体验类 class User { fullName: string; lastName:string; firstName:string; constructor(firstName:string, lastName:string) { this.firstName = firstName; this.lastName = lastName; this.fullName = firstName + \" \" + lastName; } } function greeter(user : User) { return \"Hello, \" + user.firstName + \" \" + user.lastName; } let user = new User(\"Jane\", \"M.\"); document.body.innerHTML = greeter(user); Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"ts/2.html":{"url":"ts/2.html","title":"2.基础类型","keywords":"","body":" 基础类型 布尔值 最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。 let isDone: boolean = false; 数字类型 和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 支持十进制，十六进制，二进制和八进制字面量。 //十进制 数字 6 let decLiteral: number = 6; //十六进制 6 let hexLiteral: number = 0xf00d; //二进制 6 let binaryLiteral: number = 0b1010; //八进制 6 let octalLiteral: number = 0o744; 字符串 let name: string = \"bob\"; name = \"smith\"; 字符串的拼接 let name: string = `Gene`; let age: number = 37; let sentence: string = `Hello, my name is ${ name }. I'll be ${ age + 1 } years old next month.`; 数组 数组有2种定义方式 let list: number[] = [1, 2, 3]; //使用数组泛型 let list: Array = [1, 2, 3]; 元组 Tuple TS中还是加入了元祖类型 （感觉最近5-10年推出的语言都有啊）。 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 // 定义元组类型 let x: [string, number]; // 赋值 x = ['hello', 10]; //这样赋值是错误的 x = [10, 'hello']; 当访问一个已知索引的元素，会得到正确的类型： console.log(x[0].substr(1)); // 正确 console.log(x[1].substr(1)); // 错误 当访问一个越界的元素，会使用联合类型替代： x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型 console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString x[6] = true; // Error, 布尔不是(string | number)类型 注意：在TS 3.1版本之前 访问越界元素 是不会报错的 在3.1版本后就会报错。 枚举 enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 enum Color {Red, Green, Blue} let c: Color = Color.Green; // 0 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号： enum Color {Red = 1, Green, Blue} let c: Color = Color.Green; //2 如果手动赋值所有的值 enum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; //2 可以通过枚举值 反显 枚举名字。 enum Color {Red = 1, Green, Blue} let colorName: string = Color[2]; console.log(colorName); // 显示'Green'因为上面代码里它的值是2 Any 如果你在声明变量的时候 类型不固定 想跳过类型检查 就可以使用any类型 let notSure: any = 4; notSure = \"maybe a string instead\"; notSure = false; // okay, definitely a boolean 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, \"free\"]; list[1] = 100; void 某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： void 声明的变量 只能声明 null 或undefined function warnUser(): void { console.log(\"This is my warning message\"); } let unusable: void = undefined; null undefined TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大： let u: undefined = undefined; let n: null = null; 默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。 编译的时候尽可能地使用--strictNullChecks 可以严格模式 检查是否为null never never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\"Something failed\"); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } object object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。 declare function create(o: object | null): void; create({ prop: 0 }); // OK create(null); // OK create(42); // Error create(\"string\"); // Error create(false); // Error create(undefined); // Error 类型断言 和转换 假设你使用一个any 类型 来定义一个字符串 这时候你使用length 等方法时候 会报错的，这时候你应该转换成string 类型 再使用字符串的方法。 转换有2种方法 let someValue: any = \"this is a string\"; let strLength: number = (someValue).length; let strLength: number = (someValue as string).length; Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"ts/3.html":{"url":"ts/3.html","title":"3.接口","keywords":"","body":"接口 定义 interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: \"Size 10 Object\"}; printLabel(myObj); 可选属性 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): {color: string; area: number} { let newSquare = {color: \"white\", area: 100}; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({color: \"black\"}); 只读属性 readonly 字段 interface Point { readonly x: number; readonly y: number; } let p1: Point = { x: 10, y: 20 }; p1.x = 5; // error! TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! readonly 和const 的区别 是看要把它做为变量使用还是做为一个属性，变量用const 属性用readonly 函数类型 接口也可以定义函数类型 我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result > -1; } //参数名字 可以不同 mySearch = function(sou: string, subSt: string) { let result = sou.search(subSt); return result > -1; } //也可以自己推断 mySearch = function(src, sub) { let result = src.search(sub); return result > -1; } 可索引的类型 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[\"daniel\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： interface StringArray { [index: number]: string; } let myArray: StringArray; myArray = [\"Bob\", \"Fred\"]; let myStr: string = myArray[0]; 类 类型 可以让类来符合一种契约 可以描述属性和方法 interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 类静态部分与实例部分的区别 当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： interface ClockConstructor { new (hour: number, minute: number); } class Clock implements ClockConstructor { currentTime: Date; constructor(h: number, m: number) { } } 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。 继承接口 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 可以继承多个接口 interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke{ sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; square.penWidth = 5.0; 混合类型 一个对象可以同时做为函数和对象使用，并带有额外的属性。 interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { let counter = function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0; 接口继承类 class Control { private state: any; } interface SelectableControl extends Control { select(): void; } class Button extends Control implements SelectableControl { select() { } } class TextBox extends Control { select() { } } // 错误：“Image”类型缺少“state”属性。 class Image implements SelectableControl { select() { } } Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"ts/4.html":{"url":"ts/4.html","title":"4.类","keywords":"","body":"类 使用 class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; } } //new 关键字 let greeter = new Greeter(\"world\"); 继承 extends 关键字 class Animal { move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); } } class Dog extends Animal { bark() { console.log('Woof! Woof!'); } } const dog = new Dog(); dog.bark(); dog.move(10); dog.bark(); 公共，私有与受保护的修饰符 默认为 public 当成员被标记成 private时，它就不能在声明它的类的外部访问。 当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。 protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问 readonly 修饰符 你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 class Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; } } let dad = new Octopus(\"Man with the 8 strong legs\"); dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的. 参数属性 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性： class Octopus { readonly numberOfLegs: number = 8; constructor(readonly name: string) { } } 存取器 类的get set 方法 class Employee { fullName: string; } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { console.log(employee.fullName); } 用 set get 改写 会避免随意修改属性的问题 let passcode = \"secret passcode\"; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode && passcode == \"secret passcode\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } } } let employee = new Employee(); employee.fullName = \"Bob Smith\"; if (employee.fullName) { alert(employee.fullName); } 这段代码在默认情况下会编译失败 存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 所以编译的时候得带参数 --target es5 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"js/":{"url":"js/","title":"JavaScript进阶","keywords":"","body":"JavaScript进阶系列文章 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"js/proxy.html":{"url":"js/proxy.html","title":"1.Vue.js 3.0中的响应式","keywords":"","body":"Vue2.0和Vue.js 3.0 中实现响应式的方式分析 前言 10月5号凌晨，尤雨溪公布了 Vue 3 的源代码，目前的版本是 Pre-Alpha 。 我们知道Vue 的核心之一就是响应式系统，通过侦测数据的变化，来驱动更新视图。在Vue.js 2的版本中是通过 Object.defineProperty()函数来实现的响应式。大家早就得知在Vue新版的响应式是用 Proxy 实现的，现在我们来利用 Object.defineProperty()和 Proxy 实现一个基本的响应式骨架。 vue2.0响应式回顾 vue2.0中使用Object.defineProperty()函数来实现的响应式。重新定义属性 给属性增加setter 和getter 方法 function updateView(){ console.log('update view') } function observe(obj){ if(typeof obj !== 'object' || data == null){ return obj } for(let key in obj){ defineObserve(obj,key,data[key]) } } function defineObserve(obj,key,value){ Object.defineProperty(obj,key,{ set(newVal){ if(newVal !== value){ updateView() value = newValue } }, get(){ return value } }) } //example let data = {name:'123'} observe(data) data.name = '456' 这样是完整了初步的响应式 改变数据的时候 触发更新试图的方法 数据也发生了改变，但是如果对象中有嵌套的属性呢，例如： let data = {name:'123',age:{n:111}} data.age.n = 123456 let data = {name:'123',age:{n:111}} data.age ={n:200} data.age.n = 123456 这两种情况下 上述代码就无法满足要求了 就得使用递归的方法 去观察value function updateView(){ console.log('update view') } function observe(obj){ if(typeof obj !== 'object' || data == null){ return obj } for(let key in obj){ defineObserve(obj,key,data[key]) } } function defineObserve(obj,key,value){ //添加递归 observe(value) Object.defineProperty(obj,key,{ set(newVal){ if(newVal !== value){ //添加递归 observe(newVal) updateView() value = newValue } }, get(){ return value } }) } //example let data = {name:'123',age:{n:111}} observe(data) data.age ={n:200} data.age.n = 123456 那么对象层级非常的深，递归会导致性能不好。 问题2：如果对象的属性不存在 新增的属性也是没有响应式的 问题3：如果对象的属性值是数组类型，那么也不会触发响应式。这时候要对数组上的方法进行重写 push shift。。。 例如： let oldproto = Array.prototype; let proto = Object.create(oldproto) ['push','shift','unshift'].forEach(function(method){ proto[method] = function(){ updateView(); oldproto[method].call(this,...arguments) } }) //在observe方法 if(Array.isArray(obj)){ obj.__proto__ = proto; } proxy基础 关于 Proxy 的基础知识，可以去MDN学习。链接 实现目标 \b 实现一个响应式的核心函数命名为 reactive， 这个函数返回一个被代理之后的结果，可以通过操作这个返回结果来触发响应式。 比如实现一个有 name 属性的对象 obj，我们希望经过 reactive 函数处理之后返回一个新对象 proxyObj，我们像操作 obj 一样操作 proxyObj 对象。 let obj = { name: 'test name' } let proxyObj = reactive(obj); 例如：当修改 proxyObj.name 时会触发响应式。 其次：设置一个函数用来模拟响应式过程，这里省略掉更新dom的操作,用打印一句话来代替模拟一下。 // 提示视图需要更新 function trigger() { console.log('视图需要更新'); } 实现 reactive 函数 需要一个辅助函数 首先明确 reactive 函数接收一个参数，需要对这个参数进行代理，并返回代理后的结果。如果参数是对象才需要代理，否则直接返回。 这里需要建立一个辅助函数用来判断一个变量是否是对象： function isObject(param) { return typeof param === 'object' && param !== null; } 主体函数 使用 Proxy 时需要定义一个代理对象 handler 来对目标进行代理操作，这个对象主要有两个方法，即 get 和 set, 分别为 获取和设置属性值的时候触发。同时在内部的实现需要利用到 Reflect对象， 详情见下面的代码。 /* 返回一个被代理后的结果，通过操作这个结果可以来实现响应式, 例如视图更新 */ function reactive(target) { // 如果是个对象，则返回被代理后的结果，如果不是则直接返回 if(!isObject(target)) { return target; } // 需要定义一个代理对象来对 target 进行代理操作 // 这个对象主要有两个方法，即 get 和 set const handler = { get(target, key, receiver) { return Reflect.get(target, key, receiver); // 相当于 return target[key] }, set(target, key, value, receiver) { trigger(); return Reflect.set(target, key, value, receiver); // 相当于 target[key] = value } }; // 利用 Proxy 来代理这个对象属性 let observed = new Proxy(target, handler); return observed; } 现在我们修改 proxyObj 的name属性，发现会触发了最基本的响应式： let obj = { name: 'jjjs' } let proxyObj = reactive(obj); // 修改 name 属性，发现可以监控到 proxyObj.name = 'new Name'; console.log(proxyObj.name); //结果打印： //视图需要更新 //new Name 而且可以对本来不存在的属性进行监控： proxyObj.age = 6; console.log(proxyObj.age); //视图需要更新 //6 但是当我们想处理一个数组时，却发现会触发两次视图更新提示： let array = [1,2,3]; let obArray = reactive(array); obArray.push(4) // --结果会出现2次 视图需要更新 这个时候对reactive代码进行修改，输出set动作中每次的 key, 观察是哪个键使得函数触发了两次 function reactive(target) { const handler = { // ... set(target, key, value, receiver) { trigger(); console.log(key); // 输出变动的 key 是3 和length return Reflect.set(target, key, value, receiver); // 相当于 target[key] = value } }; // ... } 可以看出当监视数组时，数组下标的更新会触发一次，而数组length的更新也会进行触发，这就是二次触发的原因。 但我们是不需要在 length 更新时对视图进行更新的，所以需要对这里的逻辑进行修改：只对私有属性的修改动作触发视图更新。 function reactive(target) { const handler = { // ... set(target, key, value, receiver) { // 只对私有属性的修改动作触发视图更新 if(!target.hasOwnProperty(key)) { trigger(); console.log(key); } return Reflect.set(target, key, value, receiver); // 相当于 target[key] = value } }; // ... } 当需要对嵌套的对象进行获取时，例如： // 对于嵌套的对象 var obj = { name: 'jjjs', array: [1,2,3] } var proxyObj = reactive(obj); proxyObj.array.push(4); 此时会发现，并不会触发视图需要更新的提示，这时需要对对象进行递归处理： function reactive(target) { // ... const handler = { get(target, key, receiver) { const proxyTarget = Reflect.get(target, key, receiver); // 相当于获取 target[key] if(isObject(target[key])) { // 对于对象进行递归 return reactive(proxyTarget); // 递归 } return proxyTarget; }, // ... }; // ... } 然而，当多次获取代理结果时，会出现多次触发代理的情况： function reactive(target) { // ... console.log('走代理'); // 利用 Proxy 来代理这个对象属性 let observed = new Proxy(target, handler); return observed; } // 多次获取代理结果 var proxyObj = reactive(obj); var proxyObj = reactive(obj); var proxyObj = reactive(obj); var proxyObj = reactive(obj); //=>结果输出 4次 走代理 //代理被代理过的对象 reactive(proxyObj) reactive(proxyObj) reactive(proxyObj) reactive(proxyObj) 上述两种情况是我们不希望有的，我们希望对同一个对象仅做一次代理。这个时候，我们需要对已经代理过的对象进行缓存，一次在进行代理之前查询缓存判断是否已经经过了代理，只有没有经过代理的对象才走一次代理。 最适合当做缓存容器的对象是 WeakMap， 这是由于它对于对象的弱引用特性，vue3中也是使用了weakmap来维护。 Q:为什么用weekmap而不是map? A:weakmap是弱类型可以直接被回收 现在对代码进行修改，增加缓存对象： const toProxy = new WeakMap(); // 用来保存 原对象=>代理后的对象 const toRaw = new WeakMap(); //代理后的对象=>原对象 function reactive(target) { // ... if(toProxy.get(target)) { // 判断对象是否已经被代理了 return toProxy.get(target); } // ... console.log('走代理'); // 利用 Proxy 来代理这个对象属性 let observed = new Proxy(target, handler); toProxy.set(target, observed); // 保存已经代理了的对象 return observed; } 发现对同一个对象只走了一次代理，这正是我们期望的结果。 完整代码 /* demo.js */ // 定义一个缓存对象 const toProxy = new WeakMap(); // 保存代理后的对象 /* 返回一个被代理后的结果，通过操作这个结果可以来实现响应式, 例如视图更新 */ function reactive(target) { // 如果是个对象，则返回被代理后的结果，如果不是则直接返回 if(!isObject(target)) { return target; } // 判断对象是否已经被代理了 if(toProxy.get(target)) { return toProxy.get(target); } if(toRaw.has(target)){ //防止多次代理 return target } const handler = { get(target, key, receiver) { const proxyTarget = Reflect.get(target, key, receiver); // 相当于 return target[key] if(isObject(target[key])) { return reactive(proxyTarget); } return proxyTarget; }, set(target, key, value, receiver) { // 只对私有属性的修改动作触发视图更新 if(!target.hasOwnProperty(key)) { trigger(); } return Reflect.set(target, key, value, receiver); // 相当于 target[key] = value } }; // 利用 Proxy 来代理这个对象属性 let observed = new Proxy(target, handler); toProxy.set(target, observed); // 保存已代理的对象 toProxy.set(observed, target); return observed; } // 提示视图需要更新 function trigger() { console.log('视图需要更新'); } function isObject(param) { return typeof param === 'object' && param !== null; } 建立一个页面来试验一下结果 reactive // var obj = { // name: 'jjjs' // } // var proxyObj = reactive(obj); // 修改 name 属性，发现可以监控到 // proxyObj.name = 'new Name'; // console.log(proxyObj.name); // 对于本来不存在的属性也可以进行监控 // proxyObj.age = 6; // console.log(proxyObj.age); // 对于数组，会出现两次触发 // let array = [1,2,3]; // let obArray = reactive(array); // obArray.push(4) // 对于嵌套的对象 var obj = { name: 'jjjs', array: [1,2,3] } // 多次获取代理结果 var proxyObj = reactive(obj); var proxyObj = reactive(obj); var proxyObj = reactive(obj); var proxyObj = reactive(obj); // // 仅操作一次数组 // proxyObj.array.push(4); { //effect 会默认执行一次 然后等到依赖的数据变化了 会再执行一次 console.log(obj.name) }) obj.name = '456' ``` --> Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-24 22:31:41 "},"js/el.html":{"url":"js/el.html","title":"2.Element UI 源码初探","keywords":"","body":"Element UI 源码初探 需求 当我们去实现一个组件库的时候，并不会一上来就撸码，而是把它当做产品一样，思考一下我们的组件库的需求。那么对于 element-ui，除了基于 Vue.js 技术栈开发组件，它还有哪些方面的需求呢。 丰富的 feature：丰富的组件，自定义主题，国际化 文档 & demo：提供友好的文档和 demo，维护成本小，支持多语言。 安装 & 引入：支持 npm 方式和 cdn 方式，并支持按需引入。 工程化：开发，测试，构建，部署，持续集成。 需求有了，接下来就需要去思考如何去实现，本文会依据 element-ui 2.11.1 版本的源码来分析这些需求是如何实现的。当然，element-ui 早期一定不是这样子的，我们分析的这个版本已经是经过它多次迭代优化后的，如果你想去了解它的发展历程，可以去 GitHub 搜索它的历史版本。 丰富的 feature 丰富的组件 组件库最核心的还是组件，先来看一下 element-ui 组件的设计原则：一致、反馈、效率、可控。具体的解释在官网有，我就不多贴了，在 element-ui 开发团队背后，有一个强大的设计团队，这也得益于 element-ui 的创始人 sofish 在公司的话语权和地位，争取到这么好的资源。所以 element-ui 组件的外型、配色、交互都做的非常不错。 作为一个基础组件库，还有一个很重要的方面就是组件种类丰富。element-ui 官方目前有 55 个组件，分成了 6 大类，分别是基础组件、表单类组件、数据类组件、提示类组件、导航类组件和其它类型组件。这些丰富的基础组件能很好地满足大部分 PC 端 to B 业务开发需求。 开发这么多组件，需要大量的时间和精力，所以这里要非常感谢 element-ui 团队，为我们提供了这些基础组件，我们基于它们做二次开发，节约了非常多的时间 element-ui 的组件源码在 packages 目录里维护，而并不在 src 目录中。这么做并不是为了要采用 monorepo，我也并没有找到 lerna 包管理工具，这么做的目的我猜测是为了让每个组件可以单独打包，支持按需引入。但实际上想达到这个目的也并不一定需要这么去组织维护代码，我更推荐把组件库中的组件代码放在 src/components 目录中维护，然后通过修改 webpack 配置脚本也可以做到每个组件单独打包以及支持按需引入，源码放在 src 目录总是更合理的。 自定义主题 element-ui 的一大特色是支持自定义主题，你可以使用在线主题编辑器，可以修改定制 Element 所有全局和组件的 Design Tokens，并可以方便地实时预览样式改变后的视觉。同时它还可以基于新的定制样式生成完整的样式文件包，供直接下载使用，那么它是如何做到这点的呢？ element-ui 组件的样式、公共样式都在 packages/theme-chalk 文件中，并且它是可以独立发布的。element-ui 组件样式中的颜色、字体、线条等等样式都是通过变量的方式引入的，在 packages/theme-chalk/src/common/var.scss 中我们可以看到这些变量的定义，这样就给做多主题提供了方便，因为我只要修改这些变量，就可以实现组件的主题改变。 了解了基本原理，做在线替换主题也并不是难事了，我并不会详细去讲在线定制主题前端交互部分，感兴趣的同学可以自己去看源码，都在 examples 目录中，我这里只说一下本质的原理。 想要做到在线换肤，并且实时预览，需要借助 server 的帮助，比如主题可以通过一个配置去维护，用户做一系列操作后，会生成新的主题配置，把这个配置通过接口提交的方式告诉 server，然后 server 会根据这个配置做返回生成新的 CSS（具体的实施的方案未开源，大致会做一些变量替换，然后编译），新的 CSS 的样式就会覆盖默认的样式，达到了切换主题的目的。我们可以在主题编辑页面打开网络面板，可以看到有 2 个 xhr 请求. 其中，updateVarible 是一个 POST 请求，他会把你修改的的主题配置提交到后端 server，提交的数据你可以自己去查看它的 Request Payload，这个 POST 请求会返回一段 CSS 文本，然后会动态插入到 head 标签的底部，来覆盖默认样式，你可以通过审查元素看到 head 底部会动态插入一个 id 为 chalk-style 的标签。 相关代码在 examples/components/theme/loader/index.vue 中。 onAction() { this.triggertProgressBar(true); const time = +new Date(); updateVars(this.userConfig) .then(res => { this.applyStyle(res, time); }) .catch(err => { this.onError(err); }) .then(() => { this.triggertProgressBar(false); }); }, applyStyle(res, time) { if (time { updateDomHeadStyle('chalk-style', res); }); this.lastApply = time; } onAction 函数中的 updateVars 就是去发送 POST 请求，而 applyStyle 函数就是去修改和覆盖默认样式，updateDocs 函数会去更新默认主题颜色，updateDomHeadStyle 样式会添加或者修改 id 为 chalk-style 的 style 标签，目的就是覆盖默认样式，应用新主题样式。 updateVars 请求在页面加载的时候会发起，在你修改完主题配置后也会发起。 再来看一下 getVarible 请求，它是一个 GET 请求，返回的内容是主题配置页面右侧配置面板的数据源. 主题配置面板根据该数据源生成，并且当你去编辑其中一项的时候，又会发起 updateVars POST 请求，把更新的配置提交，然后后端会返回新的 CSS 并在前端生效。 另外，用户修改的配置还利用了 localStorage 在本地保存了一份，这样用户每次编辑都可以保存一份主题，下次也可以继续基于某个主题继续编辑。 不过，这么实现多主题也并非完美，为了编译加速，element-ui 把样式部分单独抽离出单独的文件，这样给开发组件的同学带来很大的不便，当你去编写组件的样式的时候，需要在多个文件中来回切换，而且这样也不符合组件就近管理的原则。但是如果把样式写在组件中，server 端去编译生成单独样式文件的时间就会增长（需要从组件中提取 CSS），所以这是一个需要权衡的问题。 国际化 说到 Vue 的国际化方案，大家很容易会联想到 vue-i18n 方案，element-ui 并未引入 vue-i18n，不过它是可以很好地与 vue-i18n 兼容的。 所有的国际化方案都会用到语言包，语言包通常会返回一个 JSON 格式的数据，element-ui 组件库的语言包在 src/locale/lang 目录下，以英语语言包为例： export default { el: { colorpicker: { confirm: 'OK', clear: 'Clear' } // ... } } 在 packages/color-picker/src/components/picker-dropdown.vue 中，我们在模板部分可以看到这个语言包的使用： t('el.colorpicker.clear') t('el.colorpicker.confirm') 模板中用到的 t 函数，它定义在 src/mixins/locale.js 中： export default { methods: { t(...args) { return t.apply(this, args); } } }; 实际上是在 src/locale/index.js 中定义的 t 函数： export const t = function(path, options) { let value = i18nHandler.apply(this, arguments); if (value !== null && value !== undefined) return value; const array = path.split('.'); let current = lang; for (let i = 0, j = array.length; i 这个函数是根据传入的 path 路径，比如我们例子中的 el.colorpicker.confirm，从语言包中找到对应的文案。其中 i18nHandler 是一个 i18n 的处理函数，这块逻辑就是用来兼容外部的 i18n 方案如 vue-i18n。 let i18nHandler = function() { const vuei18n = Object.getPrototypeOf(this || Vue).$t; if (typeof vuei18n === 'function' && !!Vue.locale) { if (!merged) { merged = true; Vue.locale( Vue.config.lang, deepmerge(lang, Vue.locale(Vue.config.lang) || {}, { clone: true }) ); } return vuei18n.apply(this, arguments); } }; export const i18n = function(fn) { i18nHandler = fn || i18nHandler; }; export const use = function(l) { lang = l || lang; }; 可以看到 i18nHandler 默认会尝试去找 Vue 原型中的 t 函数，这是 vue-i18@5.x 的实现，会在 Vue 的原型上挂载 t 方法。 另外它也暴露了 i18n 方法，可以外部传入其它的 i18n 方法，覆盖 i18nHandler。 如果没有外部提供的 i18n 方法，那么就直接找到当前的语言包 let current = lang;，接下来的逻辑就是从这个语言包对象中读到对应的字符串值，当然如果字符串需要格式化则调用 format 函数，这块逻辑同学们感兴趣可以自己看。 因此在使用对应的语言包的时候一定要注册： import lang from 'element-ui/lib/locale/lang/en' import locale from 'element-ui/lib/locale' // 设置语言 locale.use(lang) 这样就注册了英文语言包，在模板中就可以正常使用并找到对应的语言了。 文档 & demo 作为一个优秀的开源组件库，友好的文档和 demo 是必不可少的，它也能帮你招揽到不少用户。作为一个组件库的开发者和维护者，也希望用最小的成本来维护文档和 demo。 element-ui 的文档和 demo 是融为一体的，我们打开它的文档，可以看到文档不仅介绍了每个组件的使用方式，还展示了组件的各种示例，并且还可以清楚地看到每个示例的源码，对用户而言非常友好。那么 element-ui 内部是如何去编写这些 demo 和文档的呢？实际上，每个组件的文档和 demo 都是通过一个单独的 .md 文件生成的，那么它又是如何做到这点的呢？ element-ui 的 demo 源码都在 examples 目录中维护，当我们在 element-ui 工程下运行 npm run dev 的时候，会启动它的开发调试模式，并且运行官方文档和 demo。 看一下 npm scripts： \"scripts\": { \"bootstrap\": \"yarn || npm i\", \"build:file\": \"node build/bin/iconInit.js & node build/bin/build-entry.js & node build/bin/i18n.js & node build/bin/version.js\", \"dev\": \"npm run bootstrap && npm run build:file && cross-env NODE_ENV=development webpack-dev-server --config build/webpack.demo.js & node build/bin/template.js\", } 我们省略了其它的 scripts，重点看 dev 和相关的几个命令，其中 bootstrap 的作用是安装依赖，build:file 的作用是运行 build 目录下几个命令，包括对 icon、entry、i18n、version 等初始化。在执行完 bootstrap 和 build:file 后，通过 webpack-dev-server 运行 build/webpack.demo.js，这个是重点，我们来看一下这个 webpack 的配置文件。 const webpackConfig = { mode: process.env.NODE_ENV, entry: isProd ? { docs: './examples/entry.js', 'element-ui': './src/index.js' } : (isPlay ? './examples/play.js' : './examples/entry.js'), output: { path: path.resolve(process.cwd(), './examples/element-ui/'), publicPath: process.env.CI_ENV || '', filename: '[name].[hash:7].js', chunkFilename: isProd ? '[name].[hash:7].js' : '[name].js' }, resolve: { extensions: ['.js', '.vue', '.json'], alias: config.alias, modules: ['node_modules'] }, devServer: { host: '0.0.0.0', port: 8085, publicPath: '/', hot: true }, module: { rules: [ { test: /\\.vue$/, loader: 'vue-loader', options: { compilerOptions: { preserveWhitespace: false } } }, { test: /\\.md$/, use: [ { loader: 'vue-loader', options: { compilerOptions: { preserveWhitespace: false } } }, { loader: path.resolve(__dirname, './md-loader/index.js') } ] } ] } }; 由于整个配置文件内容比较长，我只保留了重点的部分，重点看一下 entry 和 module 下的 rules。 element-ui 官网本质上就是一个用 vue 开发的应用，当我们运行 npm run dev 的时候，入口文件是 examples 目录下的 entry.js： import Vue from 'vue'; import entry from './app'; import VueRouter from 'vue-router'; import Element from 'main/index.js'; import hljs from 'highlight.js'; import routes from './route.config'; import demoBlock from './components/demo-block'; import MainFooter from './components/footer'; import MainHeader from './components/header'; import SideNav from './components/side-nav'; import FooterNav from './components/footer-nav'; import title from './i18n/title'; import 'packages/theme-chalk/src/index.scss'; import './demo-styles/index.scss'; import './assets/styles/common.css'; import './assets/styles/fonts/style.css'; import icon from './icon.json'; Vue.use(Element); Vue.use(VueRouter); Vue.component('demo-block', demoBlock); Vue.component('main-footer', MainFooter); Vue.component('main-header', MainHeader); Vue.component('side-nav', SideNav); Vue.component('footer-nav', FooterNav); const globalEle = new Vue({ data: { $isEle: false } // 是否 ele 用户 }); Vue.mixin({ computed: { $isEle: { get: () => (globalEle.$data.$isEle), set: (data) => {globalEle.$data.$isEle = data;} } } }); Vue.prototype.$icon = icon; // Icon 列表页用 const router = new VueRouter({ mode: 'hash', base: __dirname, routes }); router.afterEach(route => { // https://github.com/highlightjs/highlight.js/issues/909#issuecomment-131686186 Vue.nextTick(() => { const blocks = document.querySelectorAll('pre code:not(.hljs)'); Array.prototype.forEach.call(blocks, hljs.highlightBlock); }); const data = title[route.meta.lang]; for (let val in data) { if (new RegExp('^' + val, 'g').test(route.name)) { document.title = data[val]; return; } } document.title = 'Element'; ga('send', 'event', 'PageView', route.name); }); new Vue({ // eslint-disable-line ...entry, router }).$mount('#app'); 入口文件做的事情很简单，全引入的方式注册了 element-ui 组件库，注册了一些官网用到的组件，注册了路由以及路由的全局钩子函数。 这里我们要重点关注路由部分，路由的配置都在 examples/route.config.js 中： import navConfig from './nav.config'; import langs from './i18n/route'; const LOAD_MAP = { 'zh-CN': name => { return r => require.ensure([], () => r(require(`./pages/zh-CN/${name}.vue`)), 'zh-CN'); }, 'en-US': name => { return r => require.ensure([], () => r(require(`./pages/en-US/${name}.vue`)), 'en-US'); }, 'es': name => { return r => require.ensure([], () => r(require(`./pages/es/${name}.vue`)), 'es'); }, 'fr-FR': name => { return r => require.ensure([], () => r(require(`./pages/fr-FR/${name}.vue`)), 'fr-FR'); } }; const load = function(lang, path) { return LOAD_MAP[lang](path); }; const LOAD_DOCS_MAP = { 'zh-CN': path => { return r => require.ensure([], () => r(require(`./docs/zh-CN${path}.md`)), 'zh-CN'); }, 'en-US': path => { return r => require.ensure([], () => r(require(`./docs/en-US${path}.md`)), 'en-US'); }, 'es': path => { return r => require.ensure([], () => r(require(`./docs/es${path}.md`)), 'es'); }, 'fr-FR': path => { return r => require.ensure([], () => r(require(`./docs/fr-FR${path}.md`)), 'fr-FR'); } }; const loadDocs = function(lang, path) { return LOAD_DOCS_MAP[lang](path); }; const registerRoute = (navConfig) => { let route = []; Object.keys(navConfig).forEach((lang, index) => { let navs = navConfig[lang]; route.push({ path: `/${ lang }/component`, redirect: `/${ lang }/component/installation`, component: load(lang, 'component'), children: [] }); navs.forEach(nav => { if (nav.href) return; if (nav.groups) { nav.groups.forEach(group => { group.list.forEach(nav => { addRoute(nav, lang, index); }); }); } else if (nav.children) { nav.children.forEach(nav => { addRoute(nav, lang, index); }); } else { addRoute(nav, lang, index); } }); }); function addRoute(page, lang, index) { const component = page.path === '/changelog' ? load(lang, 'changelog') : loadDocs(lang, page.path); let child = { path: page.path.slice(1), meta: { title: page.title || page.name, description: page.description, lang }, name: 'component-' + lang + (page.title || page.name), component: component.default || component }; route[index].children.push(child); } return route; }; let route = registerRoute(navConfig); const generateMiscRoutes = function(lang) { let guideRoute = { path: `/${ lang }/guide`, // 指南 redirect: `/${ lang }/guide/design`, component: load(lang, 'guide'), children: [{ path: 'design', // 设计原则 name: 'guide-design' + lang, meta: { lang }, component: load(lang, 'design') }, { path: 'nav', // 导航 name: 'guide-nav' + lang, meta: { lang }, component: load(lang, 'nav') }] }; let themeRoute = { path: `/${ lang }/theme`, component: load(lang, 'theme-nav'), children: [ { path: '/', // 主题管理 name: 'theme' + lang, meta: { lang }, component: load(lang, 'theme') }, { path: 'preview', // 主题预览编辑 name: 'theme-preview-' + lang, meta: { lang }, component: load(lang, 'theme-preview') }] }; let resourceRoute = { path: `/${ lang }/resource`, // 资源 meta: { lang }, name: 'resource' + lang, component: load(lang, 'resource') }; let indexRoute = { path: `/${ lang }`, // 首页 meta: { lang }, name: 'home' + lang, component: load(lang, 'index') }; return [guideRoute, resourceRoute, themeRoute, indexRoute]; }; langs.forEach(lang => { route = route.concat(generateMiscRoutes(lang.lang)); }); route.push({ path: '/play', name: 'play', component: require('./play/index.vue') }); let userLanguage = localStorage.getItem('ELEMENT_LANGUAGE') || window.navigator.language || 'en-US'; let defaultPath = '/en-US'; if (userLanguage.indexOf('zh-') !== -1) { defaultPath = '/zh-CN'; } else if (userLanguage.indexOf('es') !== -1) { defaultPath = '/es'; } else if (userLanguage.indexOf('fr') !== -1) { defaultPath = '/fr-FR'; } route = route.concat([{ path: '/', redirect: defaultPath }, { path: '*', redirect: defaultPath }]); export default route; 这个路由配置文件提供了指南、组件、主题、资源等多个路由页面的配置，并且支持了多语言，我们重点关注一下组件路由是如何生成的，它主要通过 registerRoute(navConfig) 方法生成。 其中 navConfig 读取的是 examples/nav.config.json 文件，这个配置文件太长我就不贴了，它包括了多个语言的配置，维护了左侧组件导航菜单路径映射关系。 registerRoute 函数内部就是遍历 navConfig，根据它内部元素的数据结构生成路由配置，如果数据中有 children 则生成子路由。 我们知道 Vue Router 的本质是根据不同的 URL path，router-view 组件映射到对应的路由组件，对于每一个组件的路由，都是通过 addRoute(nav, lang, index) 方法生成的，该方法内部又调用了 loadDocs(lang, page.path) 获取到对应的路由组件。 const loadDocs = function(lang, path) { return LOAD_DOCS_MAP[lang](path); }; const LOAD_DOCS_MAP = { 'zh-CN': path => { return r => require.ensure([], () => r(require(`./docs/zh-CN${path}.md`)), 'zh-CN'); }, 'en-US': path => { return r => require.ensure([], () => r(require(`./docs/en-US${path}.md`)), 'en-US'); }, 'es': path => { return r => require.ensure([], () => r(require(`./docs/es${path}.md`)), 'es'); }, 'fr-FR': path => { return r => require.ensure([], () => r(require(`./docs/fr-FR${path}.md`)), 'fr-FR'); } }; 以中文为例，我们获取到某个 path 下的路由组件就是一个工厂函数，它对应加载的组件路径是 exmaples/docs/zh-CN/${path}.md。这里要注意的是，和我们普通的异步组件加载方式不同，这里加载的居然是一个 .md 文件，而并非一个 .vue 文件，但却能和 .vue 文件一样能渲染成一个 Vue 组件，这是如何做到的呢？ 我们知道，webpack 的理念是一切资源都可以 require，只要配置了对应的 loader。回到 build/webpack.demo.js，我们发现对于 .md 文件我们配置了相应的 loader： { test: /\\.md$/, use: [ { loader: 'vue-loader', options: { compilerOptions: { preserveWhitespace: false } } }, { loader: path.resolve(__dirname, './md-loader/index.js') } ] } 对于 .md 文件，这里 use 数组中配置了 2 项，它们执行顺序是逆序的，也就是先执行 md-loader，再执行 vue-loader，md-loader 的代码在 build/md-loader/index.js 中： const { stripScript, stripTemplate, genInlineComponentText } = require('./util'); const md = require('./config'); module.exports = function(source) { const content = md.render(source); const startTag = ''; const endTagLen = endTag.length; let componenetsString = ''; let id = 0; // demo 的 id let output = []; // 输出的内容 let start = 0; // 字符串开始位置 let commentStart = content.indexOf(startTag); let commentEnd = content.indexOf(endTag, commentStart + startTagLen); while (commentStart !== -1 && commentEnd !== -1) { output.push(content.slice(start, commentStart)); const commentContent = content.slice(commentStart + startTagLen, commentEnd); const html = stripTemplate(commentContent); const script = stripScript(commentContent); let demoComponentContent = genInlineComponentText(html, script); const demoComponentName = `element-demo${id}`; output.push(``); componenetsString += `${JSON.stringify(demoComponentName)}: ${demoComponentContent},`; // 重新计算下一次的位置 id++; start = commentEnd + endTagLen; commentStart = content.indexOf(startTag, start); commentEnd = content.indexOf(endTag, commentStart + startTagLen); } // 仅允许在 demo 不存在时，才可以在 Markdown 中写 script 标签 // todo: 优化这段逻辑 let pageScript = ''; if (componenetsString) { pageScript = ` export default { name: 'component-doc', components: { ${componenetsString} } } `; } else if (content.indexOf('') === 0) { // 硬编码，有待改善 start = content.indexOf('') + ''.length; pageScript = content.slice(0, start); } output.push(content.slice(start)); return ` ${output.join('')} ${pageScript} `; }; webpack loader 的原理很简单，输入是文件的原始内容，返回的是经过 loader 处理后的内容。对于 md-loader，输入的是 .md 文档，输出的则是一个 Vue SFC 格式的字符串，这样它的输出就可以作为下一个 vue-loader 的输入做处理了。 我们来简单看一下 md-loader 中间处理过程。首先执行了 md.render(source) 对 md 文档解析，提取文档中 :::demo {content} ::: 内容，分别生成一些 Vue 的模板字符串，然后再从这个模板字符串中循环查找 包裹的内容，从中提取模板字符串到 output 中，提取 script 到 componenetsString 中，然后构造 pageScript，最后返回的内容就是： return ` ${output.join('')} ${pageScript} `; 最终生成的字符串满足我们通常编写的 .vue SFC 格式，它会作为下一个 vue-loader 的输入，所以这样我们就相当于通过加载一个 .md 格式的文件的方式加载了 Vue 组件。 这里面还有很多和 .md 文件解析的细节，如果你对最终生成的 output 和 pageScript 代码是什么感兴趣，建议你自己调试一番。 element-ui 这种文档和 demo 的实现方式是非常巧妙的，大大减少了 demo 和文档的维护成本，并且对于用户来说也非常友好，如果你也为自己的库构建文档，不妨参考它的实现。 安装 & 引入 通常 JS 库都会支持 npm 和 CDN 2 种安装方式，element-ui 也不例外。 先说一下 CDN 的安装方式，实际上 element-ui 会把所有组件打包生成一份 CSS 和 JS，官方也提供了例子： CDN 安装方式有它的好处，不需要构建工具，开箱即用，但缺点也很明显，全量引入了所有组件，体积非常大。 由于大部分人在开发 Vue 项目都是基于 vue-cli 脚手架初始化项目的，所以更推荐使用 npm 方式安装。 npm i element-ui -S 说到 npm 安装，不得不提 element-ui 提供的 2 种组件引入方式，完整引入和部分引入。 支持完整引入非常容易，把所有组件打包成一份 CSS 和 JS，并且在 package.json 中配置： \"main\": \"lib/element-ui.common.js\" 这样当用户执行 import ElementUI from 'element-ui' 的时候就可以完整引入了组件的 JS 代码了。正如我们之前说的，element-ui 会单独发布 CSS，所以你还需要 import 'element-ui/lib/theme-chalk/index.css'。 完整引入的好处是方便，只需要 2 行代码就可以完整地使用 element-ui 所有的组件，但缺点也很明显，引入的组件包体积很大，通常一个项目也用不到所有的组件，会有资源浪费。 因此最佳实践就是按需引入： import Vue from 'vue' import { Button } from 'element-ui' Vue.component(Button.name, Button) 大部分人这么用的时候会觉得理所当然，不知道大家有没有想过：为什么这种引入方式可以实现按需引入呢？要搞清楚这个问题，就要搞清楚 import { Button } from 'element-ui' 这个背后都做了什么。 其实官网已经有答案了，在使用按需引入的时候，要借助 babel-plugin-component 这个 webpack 插件，并且配置 .babelrc： { \"presets\": [[\"es2015\", { \"modules\": false }]], \"plugins\": [ [ \"component\", { \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" } ] ] } 实际上它是把 import { Button } from 'element-ui' 转换成： var button = require('element-ui/lib/button') require('element-ui/lib/theme-chalk/button.css') 这样我们就精准地引入了对应 lib 下的 Button 组件的 JS 和 CSS 代码了，也就实现了按需引入 Button 组件。 element-ui 这种按需引入的方式虽然方便，但背后却要解决几个问题，由于我们支持每个组件可以单独引入，那么如果产生了组件依赖并且同时按需引入的时候，代码冗余问题怎么解决。举个例子，在 element-ui 中，Table 组件依赖了 CheckBox 组件，那么当我同时引入了 Table 组件和 CheckBox 组件的时候，会不会产生代码冗余呢？ import { Table, CheckBox } from 'element-ui' 如果你不做任何处理的话，答案是会，你最终引入的包会有 2 份 CheckBox 的代码。那么 element-ui 是怎么解决这个问题的呢？实际上只是部分解决了，它的 webpack 配置文件中配置了 externals，在 build/config.js 中我们可以看到这些具体的配置： var externals = {}; Object.keys(Components).forEach(function(key) { externals[`element-ui/packages/${key}`] = `element-ui/lib/${key}`; }); externals['element-ui/src/locale'] = 'element-ui/lib/locale'; utilsList.forEach(function(file) { file = path.basename(file, '.js'); externals[`element-ui/src/utils/${file}`] = `element-ui/lib/utils/${file}`; }); mixinsList.forEach(function(file) { file = path.basename(file, '.js'); externals[`element-ui/src/mixins/${file}`] = `element-ui/lib/mixins/${file}`; }); transitionList.forEach(function(file) { file = path.basename(file, '.js'); externals[`element-ui/src/transitions/${file}`] = `element-ui/lib/transitions/${file}`; }); externals = [Object.assign({ vue: 'vue' }, externals), nodeExternals()]; externals 可以防止将这些 import 的包打包到 bundle 中，并在运行时再去从外部获取这些扩展依赖。 我们来看一下打包后的 lib/table.js，我们可以看到编译后的 table.js 对 CheckBox 组件的依赖引入： module.exports = require(\"element-ui/lib/checkbox\"); 这么处理的话，就不会打包生成 2 份 CheckBox JS 部分的代码了，但是对于 CSS 部分，element-ui 并未处理冗余情况，可以看到 lib/theme-chalk/checkbox.css 和 lib/theme-chalk/table.css 中都会有 CheckBox 组件的 CSS 样式。 其实，要解决按需引入的 JS 和 CSS 的冗余问题并非难事，可以用后编译的思想，即依赖包提供源码，而编译交给应用处理，这样不仅不会有组件冗余代码，甚至连编译的冗余代码都不会有 工程化 前端对于工程化的要求越来越高，element-ui 作为一个组件库，它在工程化方面做了哪些事情呢？ 首先是开发阶段，为了保证大家代码风格的一致性，使用了 ESLint，甚至专门写了 eslint-config-elemefe 作为 ESint 的扩展规则配置；为了方便本地开发调试，借助了 webpack 并配置了 Hot Reload；利用模块化开发的思想把组件依赖的一些公共模块放在了 src 目录，并依据功能拆分出 directives、locale、mixins、transitions、utils 等模块。 其次是测试方面，使用了 karma 测试框架，为每一个组件编写了单元测试，并且利用 Travis CI 集成了测试。 接着是构建方面，element-ui 编写了很多 npm scripts，以 dist 这个 script 为例： \"dist\": \"npm run clean && npm run build:file && npm run lint && webpack --config build/webpack.conf.js && webpack --config build/webpack.common.js && webpack --config build/webpack.component.js && npm run build:utils && npm run build:umd && npm run build:theme\" 它内部会依次执行多个命令，最终会生成 lib 目录和打包后的文件。我并不打算介绍所有的命令，感兴趣同学可自行研究，这里我想介绍一下 build:file 这个 script 做的事情： \"build:file\": \"node build/bin/iconInit.js & node build/bin/build-entry.js & node build/bin/i18n.js & node build/bin/version.js\" 这里会依次执行 build/bin 目录下的一些 Node 脚本，对 icon、entry、i18n、version 等做了一系列的初始化工作，它们的内容都是根据一些规则做文件的 IO，这么做的好处就是完全通过工具的手段自动化生成文件，比人工靠谱且效率更高，这波操作非常值得我们学习和应用。 最后是部署，通过 pub 这个 npm script 完成： \"pub\": \"npm run bootstrap && sh build/git-release.sh && sh build/release.sh && node build/bin/gen-indices.js && sh build/deploy-faas.sh\" 主要是通过运行一系列的 bash 脚本，实现了代码的提交、合并、版本管理、npm 发布、官网发布等，让整个发布流程自动化完成，脚本具体内容感兴趣的同学可自行查看。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"js/bind.html":{"url":"js/bind.html","title":"3.bind的模拟实现","keywords":"","body":"JavaScript进阶之bind的模拟实现 通过bind函数的模拟实现，带大家真正了解bind的特性 bind 一句话介绍 bind: bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 返回函数的模拟实现 从第一个特点开始，我们举个例子： var foo = { value: 1 }; function bar() { console.log(this.value); } // 返回了一个函数 var bindFoo = bar.bind(foo); bindFoo(); // 1 关于指定 this 的指向，我们可以使用 call 或者 apply 实现， // 第一版 Function.prototype.bind2 = function (context) { var self = this; return function () { return self.apply(context); } } 此外，之所以 return self.apply(context)，是考虑到绑定函数可能是有返回值的，依然是这个例子： var foo = { value: 1 }; function bar() { return this.value; } var bindFoo = bar.bind(foo); console.log(bindFoo()); // 1 传参的模拟实现 接下来看第二点，可以传入参数。这个就有点让人费解了，我在 bind 的时候，是否可以传参呢？我在执行 bind 返回的函数的时候，可不可以传参呢？让我们看个例子： var foo = { value: 1 }; function bar(name, age) { console.log(this.value); console.log(name); console.log(age); } var bindFoo = bar.bind(foo, 'daisy'); bindFoo('18'); // 1 // daisy // 18 函数需要传 name 和 age 两个参数，竟然还可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 这可咋办？不急，我们用 arguments 进行处理： // 第二版 Function.prototype.bind2 = function (context) { var self = this; // 获取bind2函数从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1); return function () { // 这个时候的arguments是指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); } } 构造函数效果的模拟实现 完成了这两点，最难的部分到啦！因为 bind 还有一个特点，就是 一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。举个例子： var value = 2; var foo = { value: 1 }; function bar(name, age) { this.habit = 'shopping'; console.log(this.value); console.log(name); console.log(age); } bar.prototype.friend = 'kevin'; var bindFoo = bar.bind(foo, 'daisy'); var obj = new bindFoo('18'); // undefined // daisy // 18 console.log(obj.habit); console.log(obj.friend); // shopping // kevin 注意：尽管在全局和 foo 中都声明了 value 值，最后依然返回了 undefind，说明绑定的 this 失效了，如果大家了解 new 的模拟实现，就会知道这个时候的 this 已经指向了 obj。 所以我们可以通过修改返回的函数的原型来实现，让我们写一下： // 第三版 Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fBound ? this : context, args.concat(bindArgs)); } // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound; } 构造函数效果的优化实现 但是在这个写法中，我们直接将 fBound.prototype = this.prototype，我们直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype。这个时候，我们可以通过一个空函数来进行中转： // 第四版 Function.prototype.bind2 = function (context) { var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; } 到此为止，大的问题都已经解决，给自己一个赞！o(￣▽￣)ｄ 三个小问题 接下来处理些小问题: 1.apply 这段代码跟 MDN 上的稍有不同 在 MDN 中文版讲 bind 的模拟实现时，apply 这里的代码是： self.apply(this instanceof self ? this : context || this, args.concat(bindArgs)) 多了一个关于 context 是否存在的判断，然而这个是错误的！ 举个例子： var value = 2; var foo = { value: 1, bar: bar.bind(null) }; function bar() { console.log(this.value); } foo.bar() // 2 以上代码正常情况下会打印 2，如果换成了 context || this，这段代码就会打印 1！ 所以这里不应该进行 context 的判断，大家查看 MDN 同样内容的英文版，就不存在这个判断！ 2.调用 bind 的不是函数咋办？ 不行，我们要报错！ if (typeof this !== \"function\") { throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); } 3.我要在线上用 那别忘了做个兼容： Function.prototype.bind = Function.prototype.bind || function () { …… }; 当然最好是用 es5-shim 啦。 最终代码 所以最最后的代码就是： Function.prototype.bind2 = function (context) { if (typeof this !== \"function\") { throw new Error(\"Function.prototype.bind - what is trying to be bound is not callable\"); } var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function () {}; var fBound = function () { var bindArgs = Array.prototype.slice.call(arguments); return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); } fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; } Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-24 22:30:30 "},"js/proto.html":{"url":"js/proto.html","title":"4.JS原型和原型链","keywords":"","body":"JavaScript进阶之从原型到原型链 构造函数创建对象 我们先使用构造函数创建一个对象： function Person() { } var person = new Person(); person.name = 'Kevin'; console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype 每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： function Person() { } // 虽然写在注释里，但是你要注意： // prototype是函数才会有的属性 Person.prototype.name = 'Kevin'; var person1 = new Person(); var person2 = new Person(); console.log(person1.name) // Kevin console.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： __proto__ 这是每一个JavaScript对象(除了 null )都具有的一个属性，叫__proto__，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： function Person() { } var person = new Person(); console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor 指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor﻿，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： function Person() { } console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： function Person() { } Person.prototype.name = 'Kevin'; var person = new Person(); person.name = 'Daisy'; console.log(person.name) // Daisy delete person.name; console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__ ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： var obj = new Object(); obj.name = 'Kevin' console.log(obj.name) // Kevin 所以原型对象是通过 Object 构造函数生成的，结合之前所讲，实例的 __proto__ 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链 那 Object.prototype 的原型呢？ null，我们可以打印： console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.__proto__ 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充 最后，补充三点大家可能不会注意的地方： constructor 首先是 constructor 属性，我们看个例子： function Person() { } var person = new Person(); console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： person.constructor === Person.prototype.constructor __proto__ 其次是 __proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？ 最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-24 23:22:11 "},"js/ui.html":{"url":"js/ui.html","title":"5.Vue cli3 库模式搭建组件库并发布到 npm","keywords":"","body":"详解：Vue cli3 库模式搭建组件库并发布到 npm流程 本文的目的就是让读者能通过此文，小能做一个简单的插件供人使用，大能架构和维护一个组件库不在话下。以下一个简单的颜色选择器插件vColorPicker讲述从开发到上线到npm的流程。 用到的技术栈 如何通过新版脚手架创建项目，这里就不提了，自行看官方文档。 Vue-cli3: 新版脚手架的库模式，可以让我们很轻松的创建打包一个库（使用脚手架版本3.8.3） npm：组件库将存放在npm webpack：修改配置需要一点 webapck 的知识。 流程 想要搭建一个组件库，我们必须先要有一个大概的思路。 规划目录结构 配置项目以支持目录结构 编写组件 编写示例 配置使用库模式打包编译 发布到npm 规划目录结构 1.创建项目 在指定目录中使用命令创建一个默认的项目，或者根据自己需要自己选择。 $ vue create . 2.调整目录 我们需要一个目录存放组件，一个目录存放示例，按照以下方式对目录进行改造。 为什么要这么改呢？ 因为 我看了Element UI 源码 就是这么整的QAQ，站在巨人的肩膀上编程。 . ... |-- examples // 原 src 目录，改成 examples 用作示例展示 |-- packages // 新增 packages 用于编写存放组件 ... . 配置项目以支持新的目录结构 我们通过上一步的目录改造后，会遇到两个问题。 src目录更名为examples，导致项目无法运行 新增packages目录，该目录未加入webpack编译 注：cli3 提供一个可选的 vue.config.js 配置文件。如果这个文件存在则他会被自动加载，所有的对项目和webpack的配置，都在这个文件中。 1.重新配置入口，修改配置中的 pages 选项 新版 Vue CLI 支持使用 vue.config.js 中的 pages 选项构建一个多页面的应用。 这里使用 pages 修改入口到 examples module.exports = { // 修改 src 目录 为 examples 目录 pages: { index: { entry: 'examples/main.js', template: 'public/index.html', filename: 'index.html' } } } 2.支持对 packages 目录的处理，修改配置中的 chainWebpack 选项 packages 是我们新增的一个目录，默认是不被 webpack 处理的，所以需要添加配置对该目录的支持。 chainWebpack 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。 module.exports = { // 修改 src 为 examples pages: { index: { entry: 'examples/main.js', template: 'public/index.html', filename: 'index.html' } }, // 扩展 webpack 配置，使 packages 加入编译 chainWebpack: config => { config.module .rule('js') .include .add('/packages') .end() .use('babel') .loader('babel-loader') .tap(options => { // 修改它的选项... return options }) } } 关于webpack的链式操作可以看 这里 啦。 编写组件 以上我们已配置好对新目录架构的支持，接下来我们尝试编写组件。以下我们以一个已发布到 npm 的小插件作为示例。 GitHub - 颜色选择器-vcolorpicker 1.创建一个新组件 在 packages 目录下，所有的单个组件都以文件夹的形式存储，所有这里创建一个目录 color-picker/ 在 color-picker/ 目录下创建 src/ 目录存储组件源码 在 /color-picker 目录下创建 index.js 文件对外提供对组件的引用。 修改 /packages/color-picker/index.js文件，对外提供引用。 # /packages/color-picker/index.js // 导入组件，组件必须声明 name import colorPicker from './src/color-picker.vue' // 为组件提供 install 安装方法，供按需引入 colorPicker.install = function (Vue) { Vue.component(colorPicker.name, colorPicker) } // 默认导出组件 export default colorPicker 2.整合所有的组件，对外导出，即一个完整的组件库 修改 /packages/index.js 文件，对整个组件库进行导出。 // 导入颜色选择器组件 import colorPicker from './color-picker' // 存储组件列表 const components = [ colorPicker ] // 定义 install 方法，接收 Vue 作为参数。如果使用 use 注册插件，则所有的组件都将被注册 const install = function (Vue) { // 判断是否安装 if (install.installed) return // 遍历注册全局组件 components.map(component => Vue.component(component.name, component)) } // 判断是否是直接引入文件 if (typeof window !== 'undefined' && window.Vue) { install(window.Vue) } export default { // 导出的对象必须具有 install，才能被 Vue.use() 方法安装 install, // 以下是具体的组件列表 colorPicker } 编写示例 1、在示例中导入组件库 import Vue from 'vue' import App from './App.vue' // 导入组件库 import ColorPicker from './../packages/index' // 注册组件库 Vue.use(ColorPicker) Vue.config.productionTip = false new Vue({ render: h => h(App) }).$mount('#app') 2、在示例中使用组件库中的组件 在上一步用使用 Vue.use() 全局注册后，即可在任意页面直接使用了，而不需另外引入。当然也可以按需引入。 export default { data () { return { color: '#ff0000' } }, methods: { headleChangeColor () { console.log('颜色改变') } } } 发布到 npm，方便直接在项目中引用 到此为止我们一个完整的组件库已经开发完成了，接下来就是发布到 npm 以供后期使用。 1.package.json 中新增一条编译为库的命令 在库模式中，Vue是外置的，这意味着即使在代码中引入了 Vue，打包后的文件也是不包含Vue的。 Vue Cli3 构建目标：库 以下我们在 scripts 中新增一条命令 npm run lib --target: 构建目标，默认为应用模式。这里修改为 lib 启用库模式。 --dest : 输出目录，默认 dist。这里我们改成 lib [entry]: 最后一个参数为入口文件，默认为 src/App.vue。这里我们指定编译 packages/ 组件库目录。\"scripts\": { // ... \"lib\": \"vue-cli-service build --target lib --name vcolorpicker --dest lib packages/index.js\" } 执行编译库命令$ npm run lib 2.配置 package.json 文件中发布到 npm 的字段 name: 包名，该名字是唯一的。可在 npm 官网搜索名字，如果存在则需换个名字。 version: 版本号，每次发布至 npm 需要修改版本号，不能和历史版本号相同。 description: 描述。 main: 入口文件，该字段需指向我们最终编译后的包文件。 keyword：关键字，以空格分离希望用户最终搜索的词。 author：作者 private：是否私有，需要修改为 false 才能发布到 npm license： 开源协议 以下为参考设置 { \"name\": \"vcolorpicker\", \"version\": \"0.1.5\", \"description\": \"基于 Vue 的颜色选择器\", \"main\": \"lib/vcolorpicker.umd.min.js\", \"keyword\": \"vcolorpicker colorpicker color-picker\", \"private\": false } 3.添加 .npmignore 文件，设置忽略发布文件 我们发布到 npm 中，只有编译后的 lib 目录、package.json、README.md才是需要被发布的。所以我们需要设置忽略目录和文件。 和 .gitignore 的语法一样，具体需要提交什么文件，看各自的实际情况。 # 忽略目录 examples/ packages/ public/ # 忽略指定文件 vue.config.js babel.config.js *.map 4.登录到 npm 首先需要到 npm 上注册一个账号，注册过程略。 如果配置了淘宝镜像，先设置回npm镜像： $ npm config set registry http://registry.npmjs.org 然后在终端执行登录命令，输入用户名、密码、邮箱即可登录。 $ npm login 5.发布到 npm 执行发布命令，发布组件到 npm $ npm publish 6.发布成功 发布成功后稍等几分钟，即可在 npm 官网搜索到。 7.使用新发布的组件库 安装 $ npm install vcolorpicker -S 使用 # 在 main.js 引入并注册 import vcolorpicker from 'vcolorpicker' Vue.use(vcolorpicker) # 在组件中使用 export default { data () { return { color: '#ff0000' } } } 参考文章 从零开始搭建Vue组件库 VV-UI Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-27 21:51:56 "},"life/":{"url":"life/","title":"网事杂谈","keywords":"","body":"前言 这里是对生活的一些碎碎念 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"life/1.html":{"url":"life/1.html","title":"1.周杰伦专辑赏析--叶惠美","keywords":"","body":"叶惠美 2003年7月31日,周杰伦发行了他的全新专辑《叶惠美》，这张以他母亲命名的专辑，在7月16日全亚洲超过50家电台同步首播新专辑主打《以父之名》，全球超过5亿人同时收听，这一天也被命名为周杰伦日。 我的专辑故事 2003年，那时我才5年级，才借到我哥的磁带津津有味的听着上一张专辑《八度空间》，看着磁带的歌词也听不懂他在唱什么，觉得非常酷，当下一张专辑的消息传来，我马上跑到音像店去听，（当时几十的磁带简直是太贵了），当然是听不全的 后来上了初中 有了MP3，才回过头好好的听过这张专辑。下面我作为一个歌迷的角度来赏析这张专辑的所有歌。 以父之名 专辑主打歌。这首歌可是2003年出的，仔细想想 同时期的歌有哪些？两只蝴蝶还是刀郎？ 这首歌一出简直是把华语乐坛全部超越了一番，整首歌基于《教父》系列的世界观，歌的主题以‘天父，教父，父亲’为主轴，说明了教父的无奈，父亲的慈悲，天父的无私，格局相当大气，可谓史诗。 歌词的格局之大 语言之精，丝毫不亚于方文山，这只是黄俊郎在周杰伦歌词的处女座，编曲精良，大气 史诗级别的词，并没有一味的上什么管弦乐，有一种低调的华丽，基本编曲只有打击乐，节奏吉他和base。大多数还是周杰伦的声音为主导，周杰伦的rap水平也是非常厉害，flow和编曲感觉合二为一。（吴亦凡进来挨打！）在主歌部分低沉 ，像是在对你我诉说，副歌突然拔高，像是在对天空诉说。这首主打歌也预示着这张专辑的势如破竹，必将永载史册。音乐犹如周杰伦的玩具，在执掌之间变化万千。这首歌在我心中能在周杰伦的歌中排前五。 懦夫 周杰伦的懦夫是自己创作的一首歌，这首歌也是比较有教育意义的，众所周知，周杰伦是中国的禁毒宣传形象大使，这首歌也是唯一一首以反毒品为主题的歌。这首歌的编曲也是紧跟时尚潮流，以新金属为曲风，激烈抓耳，整首歌有2个叙事视角，一个是瘾君子看到自己的丑陋行为想回头是岸，歌中加入小孩子的声音，以小孩子的角度看到成人世界的丑陋，愤怒的控诉。 晴天 这首歌真的是初闻不知曲中意，再闻已是曲中人。是很多人青春回忆的主题曲。每个人都有初恋，初恋总是青涩美好的，这首歌虽然叫晴天，但是描写的场景全是下雨。网易云音乐歌曲评论最多的歌曲。当我们还对爱情懵懂的时候，你是否也有错过的人呢？那时错过的瞬间便是一生的遗憾。到了今天你还有什么话想对ta说呢？歌曲的本身已不再需要解读，我吹爆。MV也是很美的，周杰伦的MV初吻，雨中独奏大提琴。。当然最后还是要告诉我们喜欢一个人就要大声说出来，不要等到故事的最后，女主送给Jay一个礼物，里面写着Jay I love you. 三年二班 这首歌也是比较有意义的，刚开始的前奏，乒乓球的声音在左右切换，把乒乓球的声音作为节奏的一部分，可太秀了，这首歌听着非常有共鸣，借着乒乓球讲人生，从小家长总在说，别人家的孩子有多优秀，我必须要以他为榜样。我就是我自己，干嘛要和别人比，更何况一个人的优秀与否，只是看成绩吗，我就是跳的比别人高，跑的快，就是比别人更善良，这些行不行呢？难道打乒乓的目的就是得奖？我就是喜欢打，想出点汗行不行？凭什么要用自己的标准要求我，我的人生我要做自己的裁判。所以说那么多年轻人喜欢周杰伦，周杰伦说出了他们的心声啊 东风破 这首歌对于周杰伦来说意义非凡，现在我们都把中国风的标签贴在周杰伦身上，这首歌应该是周杰伦第一首周氏中国风，也是很多人的入坑曲，（我是双节棍入坑的哈哈）。歌词渗透古意，编曲采用中国五声音阶，中西结合，民乐器成为主角，旋律和意境几乎登峰造极，无可挑剔，这首歌风格的创立，才会有后来的菊花台，青花瓷等广为流传的歌。 你听得到 这首歌我超级喜欢。这首歌其实是首广告歌曲，知名度不是那么高。但是这首歌氛围温馨纯净，作词虽然比较简单，但是感情到位，易于理解，配合周杰伦的编曲简单美好，听得出来非常自信。副歌的编曲加上了跳跃性很强的弦乐，把内心的细腻感受描绘出来。‘我想我是太过依赖，在挂电话的刚才’。。第二段中那广为流传的彩蛋，一段话居然是倒放的‘只有你能听得到’，让人津津乐道。MV中周杰伦也是首次扮演一个渣男，在线劈腿（手动笑哭），很好看。 同一种调调 这首歌我超喜欢，又是一首吴亦凡进来挨打的歌，整首歌酷的不讲道理，那时候的我们正在叛逆期，觉得这非常爽非常酷，作曲随性而发，这首歌的rap已经似乎可以脱口而出，那些看上去随便说的“哼哼哈哈一起来”每次都忍不住一起唱，真的是太酷了，MV也是邀请了姚明友情出演。唱跳rap 篮球元素一应俱全（律师函警告）“冰过的饮料，全麦的面包，只收看音乐频道”，方文山的词也是把这种酷表达的淋漓尽致，编曲更是用琵琶作合成器 真是让人大吃一惊，原来民乐器还可以这么玩，这可是2003年啊 她的睫毛 这首歌也是同样一首吹爆的歌。这首歌真的太牛了，这首歌把周杰伦对音乐的企图心展现的淋漓尽致，在编曲中大小调的转换，让作曲人的级别上升一个level，主歌是c小调，用两拍子鼓点，副歌转A大调，色彩瞬间对比亮丽许多。第二段主歌恢复小调，等待着第二遍副歌的到来，但迎来的居然是。。。双副歌，这样子创世纪的玩法，双副歌我后来很少有听过这样的歌了。堪称惊艳，毕竟这是流行音乐啊，打破了一段副歌的旋律，结果这首歌的编曲并没有入围金曲奖最佳编曲，打败他的是《以父之名》，看来打败周杰伦的只有自己了。 爱情悬崖 这首歌我要疯狂pick！！（这句话我好像表达过很多次了）没办法这张专辑每首歌都非常非常好听。这首歌看似比较简单，徐若瑄作词，周杰伦作曲。像是对你诉说一般干净的声音，周杰伦自己说 好听的歌不一定要深奥，和弦不见得要变来变去，传达出想要表达的东西就是好歌，我对这首歌的看法也是这样，真的很好听。 梯田 这首歌可是入围过最佳作词哦，看头的那句吐槽方文山，可把我看笑了“文山啊，等你写好词，我都发下一张专辑咯，没关系，慢慢来，这首歌我自己来”，然后就以第一人称开始叙事，这首歌是表达环境保护思考的一首歌。看吧，周杰伦的歌就是表达的东西很多很有意义。MV也是拿着摄像机自拍，外婆第一次入镜哦，副歌融入了台湾省原住民风格的原生态唱法和歌剧唱法。在2004年的无与伦比演唱会中 这首歌最后还有一段rap，表达的周杰伦对音乐的态度，个性和霸气，我没有跟错人。 双刀 这首歌比较冷门，主题是对民族 历史 文化 正邪的探讨，我觉得方文山在表达鸦片战争之后中国知识分子一直在进行的反思，周杰伦的流行音乐取代了白纸黑字的文章，成为了新时代抒怀民族思绪的载体，双刀的流行成就已经成为全世界流行音乐的最高峰，歌曲主题宏大，家国仇恨，历史民族，这般宏大的叙事一般流行音乐驾驭不住，双刀做到了，在一些地方是隐晦的 表达式克制的，融入说唱，搓盘，效果绝佳。间奏段落仿佛把一部电影的四五首配乐浓缩进了一首流行音乐，制作水准也是绝对的电影级，《双刀》无疑是流行音乐领域的顶配。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-13 21:54:32 "},"life/2.html":{"url":"life/2.html","title":"2.周杰伦专辑赏析--七里香","keywords":"","body":"七里香 2004年夏天,周杰伦发行了他的全新专辑《七里香》 我的专辑故事 2004年夏天，小学毕业 准备上初中，专辑对我来说还是一个天文数字，在初一的时候 我用作业给别人抄，换来了周杰伦全新专辑磁带，让我听一个寒假，那时候我别提多开心了，回家拿起磁带，放进复读机，反复的听，听了一个过年，我觉得那是最开心的一个过年了，尽管那年亲戚没有回来几个，略显得冷清了些，但是我有周杰伦的歌就足够了，尤其听到七里香，园游会，搁浅，借口，不行了，每一首我都爱。。。 我的地盘 这首歌是周杰伦为了中国移动所作的广告歌，哎~那一句我的地盘听我的，是不是耳熟能详呢，代表年轻人酷的态度，好像从那时候开始 移动的生意开始红火哦，谁没有办过一张动感地带的手机卡呢，校园开学到处都是周杰伦的广告牌，那可真是牌面。这首歌也是非常酷啦，整首歌的尾音都是北京话儿化音，不过rap，词很好表达张扬的个性，但是词真的很难记，2004年演唱会现场忘词，直接成了freestyle 哈哈。 七里香 这首以单曲命名的专辑，是很多人的入坑曲，我一听也就喜欢了15年罢了。这首歌也是我心中最完美的一曲。30秒的前奏已然封神，风声 山谷 神秘 优雅，悦耳的旋律，东方特质的音阶，短短的时间内塞入了那么多的内容，不仔细听，根本不知道这首歌有多用心。《七里香》这首歌是当时的首播主打，很多人听到的时候同时看了MV，我觉得这是周杰伦所有歌的MV中把他拍的最帅的一个MV了，灯光的照耀下，脸部轮廓立体。MV在日本拍头文字D时取的景，这个MV拍的让我印象很深。整个歌词俨然是一首现代诗，表达了夏天 田园等主题，和陶渊明的采菊东篱下悠然见南山有些气息相通，不过陶渊明谈的是志趣，方文山谈爱情，退下庙堂，回归田园，眼前的生活只剩下雨水落叶和思念，才能毫不掩饰的把爱慕女孩的脸形容成田里熟透的番茄，很打动人。不过现在听到这首歌有点忧伤，这首歌已经是演唱会的ending歌曲了，听到这首歌就代表着演唱会要结束了，全场大合唱，让人很感动。“你是我唯一想要的了解” 借口 周杰伦的《借口》 在《无与伦比》演唱会上，一开口就是大合唱，非常让人感动。 周杰伦在提到自己的情歌时，说不会把自己的故事写进去。有时候是听情史丰富的方文山讲故事找灵感。 而他在唱情歌时，会通过想象画面让自己带入。 这首《借口》的歌词就有这个思路，每句词对应一幅画面。 「翻着我们的照片，想念若隐若现。去年的冬天，我们笑得很甜」 《借口》的副歌前三句使用同样的旋律。 一般来说如果想要增加一首歌的流行度，副歌前两句会写成相同的旋律。 周杰伦更厉害，再加一句，果然增强了洗脑感。我觉得，周杰伦的成功是他的团队共同造就的。天时地利，尤其是人和。 而他也在某次颁奖礼上，把方文山拖上台一起领最佳专辑奖，并说了这么一段话： 「大家好，我们是一个团体——我们是周家班的啦。方文山他的词写得非常好，没有他的词，就没有这样的结果。我身为一个制作人，我觉得我的编曲老师都非常好，音乐录影带都拍得非常好，我的歌迷都非常棒！」一个好汉三个帮，周家班的音乐成就，让人景仰！ 外婆 整首歌中雨声雷声营造出整首歌的氛围。主歌多变的flow，堪称中文饶舌教科书式的范本。尤其是使用雷声替代大镲，创意上很连贯、音乐上很合理、效果上很惊喜！周董小时候是由外公外婆带大的，所以跟外婆的关系是非常深。还跟外婆一起拍禁烟广告【听外婆的话，不要抽烟哦！】看来《外婆》这首歌是讲对外婆的感情吧！哦？猜错了！原来是在说对老人的关怀啊。周杰伦对社会问题一向很上心，从家暴到禁毒到环境保护。这回说的是老人赡养问题。你有多久没回家看看长辈了？回家去陪他们说说话吧，过会儿我就去看看我的外婆。 听到了第二段，哎等一下，好像主题变了？原来周杰伦醉翁之意不在酒，而是要用外婆做引子，将他自己2003年《八度空间》专辑在金曲奖颗粒无收的心情说出来。自己一个人说有点像发牢骚，所以还安排了一个「表妹」的角色跟自己唱双簧。话说歌里的「表妹」当然只是演员。 说到金曲奖，2003年周杰伦信心满满的《八度空间》在金曲奖铩羽而归，他当天接受陶晶莹的采访，说——「有一些杂七杂八的声音会觉得这张专辑，《八度空间》没有什么变化。」但是，我想要证明就是，我还是可以拿到奖。然后让歌迷觉得说，你们的眼光是对的。但现在完全出乎意料之外，我也不知道该讲什么。方文山啊，一些编曲老师啊，其实他们都是……在我眼里算是最diao的，最好的。想要帮他们争一口气，结果没想到自己也……」其实对于其他人来说，能够入围金曲奖已经是非常大的肯定。但毕竟他是当时风头正劲的周杰伦。而且从出道以来，主流音乐界对他的音乐评价一直很高。而评委对于周杰伦没有获奖的理由中，最戳周杰伦心的，就是这句——风格没有什么改变和突破嘛！所以才回怼了这一句「我告诉外婆，我没输，不需要改变」 我只想说，那时的周杰伦，真正的对手只有自己。不如说每个认真做音乐的人，真正的对手都是自己。做音乐是很苦的。在你想象中，是不是只有没什么名气的独立音乐人，会为了一句旋律的修改奋战到深夜？但其实在创作这条路上，无论是成名还是无名，大家都是一样的。因为就算上帝偶尔会握着你的手，写一两首歌，但绝大多数时候都得靠自己的学习和勤奋。想让自己的音乐被更多人听见，才华与努力只是基础。比你更有才华、更努力的大有人在！对绝大多数怀揣音乐梦想的人来说，先让自己活下去，才能继续努力，继续追逐。但是中国的知识权益理念和实践都还有很大的欠缺，让许多音乐人本应收获的权益没有办法获得。好在现在情况有所改观。最近在正版音乐平台上，周杰伦的歌都要VIP才能听了，这件事引起很多歌迷的讨论。我个人觉得，从让大家更容易接受的歌手开始，养成尊重知识和创作的观念，会对整个文化事业有长期的好处。 将军 周杰伦的《将军》这首歌，非常神奇。刚拿到《七里香》这张专辑时，看着周杰伦的军装look，又发现《将军》这个歌名，想说一定是一首讲战争的歌【这不明摆着的么，但是……哦，原来这个「将军」不是「general」，而是「checkmate」！说到下象棋……哎我是没这个天分。感觉所有棋类都是相通的，我各种棋类就是一个菜。 小学的时候学围棋，被老师羞辱，让班里下得最好的同学跟我们3个最差的车轮战。从此以后我对自己的棋类活动，再也没信心了。如果用一个词形容《将军》这首歌，我觉得是「潇洒」。 周杰伦的饶舌变化多端。不但是节奏感特强，还发挥自己对旋律的敏感，把中文饶舌带到了一个新的领域。整首歌重复145级和弦。不知道为什么我对1级到4级的写法毫无抵抗力。有点像坐车时候遇到一个小颠簸，心微颤了一下那种感觉，让人上瘾。这首歌的编曲由洪敬尧负责。 不拘泥于「中国象棋」的固有印象，有力的弦乐，跟随和声编写，简洁的副旋律线，把「中国象棋」变得很年轻很潮爆。黄俊郎的作词真的要pick一下，既华丽又接地气。「成王败寇的铁则」、「月转星移的轨迹」像是中二少年强行脑补象棋的内涵。「提着鸟笼的老头站在一旁拍我肩膀」又把想象拉回了现实。自己立起来又自己破掉，我非常欣赏这种节奏！ 搁浅 周杰伦的《搁浅》。这首歌可以算是我的本命个歌了，知道我的，微信名字一直是搁浅。我最喜欢这首歌了，唱的也不赖，蛤蛤蛤。 这首歌的主题可以总结为「愧疚」。 当你的人生还没有经历到足够引起愧疚的事情时，它只是一首普通的、伤感的情歌。 但随着时间的流逝，某一天，你可能会突然听着《搁浅》心痛不已。 南拳妈妈的弹头宋建彰作词。真是人不可貌相！ 弹头的文字居然如此细腻脆弱。这两句最是精彩—— 「风筝在阴天搁浅，想念还在等待救援」 把「搁浅」这个概念场景化，紧接着贴上心理的感受。 弱弱的小男生受了重伤，让人心疼。 钟兴民编写的弦乐依旧优秀。 北京爱乐乐团在北京OASIS录音棚录制，财大气粗不计成本。 尤其是间奏由F大调转C大调，为歌曲增加了深度。 说到《搁浅》，很多人的印象都是——太难唱了吧！ 还有较真的观众无论如何也一定要问我，这首歌中最高的音是多高。 好吧，我给你个准话！ 整首歌最高的是最后一遍副歌，从F大调转升F大调，「我只能……」的「我」。 这个「我」是高音的升C。 也就是比中央C高一个八度加一个半音，基本位于男高音真声的极限，确实是得声嘶力竭了。《搁浅》无疑是一首非常好听的周氏情歌。 乱舞春秋 三国呢，很多人都唱过。比如Tank的《三国恋》（2006）啊、林俊杰的《曹操》（2006）啊、还有杨洪基的《滚滚长江东逝水》（1995）啊啥的，2004年的《乱舞春秋》显然都跟它们不一样，《乱舞春秋》的核心就是一个字“玩”！ 三国的情怀本来是「提三尺剑以定四海」，结果在周杰伦这儿就成了个愣头青穿越时空到三国时代的故事——「一瓶可乐喜相逢，古今多少事，都付歌词中」 从黄巾之乱开始叙述，对各家势力总结性表述，还算正常的主题。 结果副歌里魔幻式的「妖兽攻击」、然后「五官差点离开身体」、「谢谢你全家我的时光机」这是要哪能啊？【不装疯卖傻，岂能安然无恙？创意玩得肆无忌惮，毫不在意苏轼和杨慎的棺材板是不是快压不住了【这么嚣张不怕被打吗？ 哼哼，韩寒在《长安乱》里说：「嚣张的人必定有自己的绝活，因为没绝活的嚣张一次基本上都挂了」《乱舞春秋》真正的嚣张在音乐上淋漓尽致。 被越传越神的八段旋律……我数学不好，数不清楚…… 我对圈子内流传很广的那一篇把《乱舞春秋》吹得神乎其技的文章想法有点不太一样。 我觉得没那么复杂。 周杰伦本人对于旋律的敏感性极高。 我们在创作时会深刻地体会到所谓的「灵感」或者我喜欢说的「自然发生」—— 当我唱着上一句的时候，下一句在脑子里紧跟着已经出来了。什么样的旋律，什么样的唱腔，什么样的质感都「自然发生」了。 所以很多创作人都有过类似的感受，那就是感觉某首歌好像早就已经存在，而只是借我们的手写出来而已。 《乱舞春秋》的变化万千，是否也是如此呢？当然了，抛开浪漫主义的想象，所谓最重要的那1%的灵感，恐怕还是那99%的汗水累积的结果。灵感可没有叫外卖那么简单。 要是没有一路以来的实验和积累，去哪里得到这一碗鸡排饭的灵感？ 困兽之斗 刘耕宏终于不是写《回到过去》那样细腻的歌，而是跟自己的外形配对了起来，贡献了一首阳刚的歌词。 有人说中国的土壤不适合摇滚乐，我觉得没错。但不代表没有好的摇滚乐作品！ 《懦夫》不摇滚吗？ 《双刀》不摇滚吗？ 《困兽之斗》不摇滚吗？ 配器、主题、曲风，萧瑟的口琴、有力又动听的旋律，哪个不摇滚？ 是不是太好听，就不够摇滚了？ 周杰伦只不过是没有被打上「摇滚歌手」的标签。 论音乐、论做人的态度，周杰伦比不少所谓的摇滚歌手，还符合我心中的Rock。 《困兽之斗》由萧瑟，到挣扎，到起身迎击，这种心理历程更真实，对挣扎中的青少年更有借鉴意义。 想到电影《搏击俱乐部》里的台词—— 「我们从小看广告，相信有一天会成为富翁、明星或摇滚巨星。但是，我们不会。那是我们逐渐面对着的现实，所以我们非常非常的愤怒」【哇这不就是《困兽之斗》吗 当我们终于成长到发现自己身在笼中的时候，可能用蛮力乱撞并不明智。 而是该沉下心来，冷静地寻找笼子的弱点，再去奋力冲破。 园游会 这首歌是周杰伦我认为所有歌当中最甜的歌了，没有之一，这首歌简直是恋爱的催化剂，第一次听就被旋律所吸引，我现在的起床闹钟铃声还是园游会，让我早上起来不会很丧，精神抖擞的去迎接新的一天。恋爱是让人快乐的事，如果不快乐，为何还要恋爱呢？“你没有化妆我却疯狂爱上”，无法掩饰方文山情感老手的身份，这可不是青少年时期暗恋自己最喜欢的女同学那个级别，而是经历过很多化妆女孩后的那种返璞归真。男人用眼睛恋爱，女人用心恋爱，《园游会》又用眼睛又用心，草地，入场券，捞鱼，气球，都是充满了恋爱的味道，让人听了有恋爱的冲动。这首歌对我意味很多，我曾经遇到了一个女孩，她没有化妆我却疯狂爱上，我能够牢记她的气质和脸庞，在一起看电影看到恐怖或刺激的时候，在一起抓娃娃的时候，一起坐电梯的时候，我安静的欣赏她慌乱的模样；我顶着大太阳 却在为她撑伞，一起逛街压马路走到半夜话题总是不断，对你表白的时候，你装忙的眼神，曾经约好这个世界一起逛。。。一切都像歌词里说的那样，那么甜，我以为我找到了歌词里的那个她，我曾经对你说，这首歌适合表白，而最后我用这首歌的歌词宣布了恋情...一切的一切是那么美好，可是...我把你弄丢了。 止战之殤 《七里香》专辑据说原来想定名为《止战之殇》，因种种原因没有通过。但可见这张专辑的核心表达应该在这首歌里。战争看来是如此迷人、如此浪漫。力量、权谋、光荣、战利品……但不生在战争国家，永远无法体会战争的可怕（《红海行动》）反对战争，消弭战争才是理性的选择。小红莓乐队的《ZOMBIE》迈克尔·杰克逊的《Heal The World》伟大的歌手必须要有伟大的思想，伟大的歌手都高歌反战。 周杰伦的《止战之殇》是他在历史上将被定义为伟大的歌手而埋下的伏笔。《七里香》专辑中，《七里香》和《止战之殇》两首歌，在歌词本上不是写着「词：方文山」，而是写着「诗：方文山」。 可见作词者方文山也好，制作人周杰伦也好，都对这两首歌高看一眼，认为与众不同。方文山不是第一次写战争主题了，《八度空间》里《最后的战役》以小见大，文笔惊人，已经让我五体投地。 而《止战之殇》又一次提升了境界。 要讲战争，可以从很多视角来讲，而从孩子的视角说，可能是一种最优解。刚才提到的《AMANI》和《Heal The World》都不约而同地选择了这种思路。 但经过与周大制作人多年的合作，方文山笔下的戏剧性和镜头感都更胜一筹。 我不必再逐句分析文笔和内容，因为它们的最终目标达成了。《止战之殇》的力量，已经堪比《辛德勒名单》中红衣女孩带来的心灵震撼。看歌词本吓了我一跳，原来《止战之殇》的编曲是周杰伦自己！ 我觉得这绝对是周杰伦到此时编曲的最高杰作，也是他自己的得意之作。只以钢琴作为主要配器【周董自己弹的哦 没有《最后的战役》那种恢弘动人的弦乐，也没有渲染氛围的各种合成器。 这样的编配就像MV中的周杰伦一样，如同一个讲故事的吟游诗人。克制、客观，却在字里行间透露出真实的情感。 充满十六分音符的钢琴伴奏紧张黑暗，异域风情的调式似乎在讲述别国的历史，但其实叙述着全人类都该面对的课题。会哭的孩子有糖吃？ 不，战争中的他们，口袋里的糖只是一种幻想。 之前看了邝盛导演的《最后的战役》电影版，我真心觉得他拍剧情片不太行。视听语言的流畅度还不够到位。 唉我大概又要因为说真话而被怼了【你算老几啊在这里放炮但是我觉得邝导自己也应该非常清楚自己的特点，所以据我所知他并不涉及影视剧的拍摄，而是专攻MV。人贵有自知之明，扬长避短，这是成才之道。对我们大家都有教育意义。 Copyright © YoungGary 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-10-24 23:05:19 "}}